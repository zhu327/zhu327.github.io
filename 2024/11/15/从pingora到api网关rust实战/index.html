<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      从Pingora到API网关：Rust实战 &middot; 跬步
    
  </title>

  
  <link rel="stylesheet" href="https://zhu327.github.io/css/poole.css">
  <link rel="stylesheet" href="https://zhu327.github.io/css/syntax.css">
  <link rel="stylesheet" href="https://zhu327.github.io/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://zhu327.github.io/assets/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="https://zhu327.github.io/assets/favicon.ico">

  
  <link rel="alternate" type="application/rss+xml" title="RSS" href="https://zhu327.github.io/feed.xml">
</head>


  <body class="theme-base-0d">

    
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">


<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>My notes and thoughts.</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item " href="https://zhu327.github.io/">Home</a>
    <a class="sidebar-nav-item " href="https://zhu327.github.io/post">Posts</a>
    <a class="sidebar-nav-item " href="https://zhu327.github.io/tags">Tags</a>

    
        <a class="sidebar-nav-item " href="https://zhu327.github.io/about/">About</a>

    <a class="sidebar-nav-item" href="https://github.com/zhu327" target="_blank">GitHub</a>
  </nav>

  <div class="sidebar-item">
    <p>&copy; 2024. All rights reserved.</p>
  </div>
</div>


    
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="https://zhu327.github.io/" title="Home">跬步</a>
            <small>On Coding</small>
          </h3>
        </div>
      </div>

      <div class="container content">


<div class="post">
  <h1 class="post-title">从Pingora到API网关：Rust实战</h1>
  <span class="post-date">Nov 15 2024</span>
  <h3 id="前言">前言</h3>

<p>在学习Rust的过程中，我主要进行了一些小工具的练习，对Rust的内存安全性和性能优势有了初步的体会，但始终没有实现过一个完整的大型项目。最近随着Rust在高性能计算领域的应用不断拓展，尤其是Pingora等项目的发布，让我看到了Rust在网络通信领域中的潜力，也激发了我用Rust来实现一个API网关的兴趣。</p>

<p>在加入腾讯之前，我曾使用OpenResty和Kong进行API网关的开发工作，后来在腾讯进一步深入参与了APISix的云原生网关项目，逐步积累了关于API网关设计、实现以及性能调优方面的经验。API网关是一个兼具架构复杂度与性能要求的系统，涉及请求路由、流量控制、身份验证等多个关键模块，恰好可以充分发挥Rust的优势。因此，我决定以Rust为基础开发一个API网关，这不仅是为了提升自己的Rust技术，更希望通过此项目进一步巩固和提升在API网关方面的知识。</p>

<p>在具体实现中，我计划基于Pingora的设计思路，打造一个APISix网关的子集功能。我已在GitHub上发布了该项目的初始版本 <a href="https://github.com/zhu327/pingsix">https://github.com/zhu327/pingsix</a>，目前实现了基础的standalone模式，包括基本的路由与反向代理功能。接下来，我将扩展插件定义，逐步实现一些典型的功能插件，最终目标是支持基于etcd的动态配置加载，以便适应多场景的API网关需求。</p>

<p></p>

<h3 id="实现-配置">实现：配置</h3>

<p>在设计 pingsix 的配置文件时，我参考了 APISix 和 Pingora 的配置文件结构，结合自身项目目标和功能，简化了部分复杂内容，同时保持了核心功能的灵活性。配置文件包含以下三个关键部分：<strong>基础配置</strong>、<strong>Listener 配置</strong> 和 <strong>资源配置</strong>，以下是详细说明与完整 YAML 示例。</p>

<h4 id="1-基础配置">1. 基础配置</h4>

<p>基础配置部分直接沿用了 Pingora 的设计，用于定义网关的全局行为和运行参数。以下是完整配置示例：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="c"># pingora config example from https://github.com/cloudflare/pingora/blob/main/docs/user_guide/conf.md</span><span class="w">
</span><span class="w"></span>pingora<span class="p">:</span><span class="w">
</span><span class="w">  </span>version<span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">              </span><span class="c"># 配置文件版本</span><span class="w">
</span><span class="w">  </span>threads<span class="p">:</span><span class="w"> </span><span class="m">2</span><span class="w">              </span><span class="c"># 工作线程数量</span><span class="w">
</span><span class="w">  </span>pid_file<span class="p">:</span><span class="w"> </span>/run/pingora.pid<span class="w"> </span><span class="c"># 保存进程ID的文件路径</span><span class="w">
</span><span class="w">  </span>upgrade_sock<span class="p">:</span><span class="w"> </span>/tmp/pingora_upgrade.sock<span class="w"> </span><span class="c"># 热升级用的Unix socket文件</span><span class="w">
</span><span class="w">  </span>user<span class="p">:</span><span class="w"> </span>nobody<span class="w">            </span><span class="c"># 运行网关的用户</span><span class="w">
</span><span class="w">  </span>group<span class="p">:</span><span class="w"> </span>webusers<span class="w">         </span><span class="c"># 运行网关的用户组</span></code></pre></div>
<p><strong>设计思路</strong>：这一部分配置是网关运行时的基础，保持简洁的同时，与 Pingora 配置完全兼容，降低了配置的学习成本。</p>

<hr />

<h4 id="2-listener-配置">2. Listener 配置</h4>

<p>Listener 是 API 网关的入口，用于定义网关监听的地址、端口以及协议类型（HTTP/HTTPS）。以下是完整配置示例：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml">listeners<span class="p">:</span><span class="w">
</span><span class="w">  </span>-<span class="w"> </span>address<span class="p">:</span><span class="w"> </span><span class="m">0.0</span>.<span class="m">0.0</span><span class="p">:</span><span class="m">8080</span><span class="w"> </span><span class="c"># HTTP监听地址和端口</span><span class="w">
</span><span class="w">  </span><span class="c"># - address: &#34;[::1]:443&#34;  # 示例：IPv6地址监听</span><span class="w">
</span><span class="w">  </span><span class="c">#   tls:                  # 配置HTTPS</span><span class="w">
</span><span class="w">  </span><span class="c">#     cert_path: /etc/ssl/server.crt # SSL证书路径</span><span class="w">
</span><span class="w">  </span><span class="c">#     key_path: /etc/ssl/server.key  # SSL私钥路径</span><span class="w">
</span><span class="w">  </span><span class="c">#   offer_h2: true         # 是否支持HTTP/2</span></code></pre></div>
<p><strong>设计思路</strong>：
- 当前支持 HTTP 和 HTTPS 协议，通过配置 <code>tls</code> 参数来开启 HTTPS。 未来可能加入类似 APISix 的 <code>Stream Proxy</code> 功能，用于支持 TCP/UDP 流量代理。</p>

<hr />

<h4 id="3-资源配置">3. 资源配置</h4>

<p>资源配置是网关的核心部分，主要定义路由规则（Router）和后端服务（Upstream）的负载均衡策略。目前 pingsix 支持的功能子集以实现反向代理为主，以下是完整示例：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="c"># 参考APISix的Standalone模式配置示例：https://apisix.apache.org/zh/docs/apisix/3.1/stand-alone/</span><span class="w">
</span><span class="w"></span><span class="c"># 完整的Router，Upstream配置参考APISix的API文档：https://apisix.apache.org/zh/docs/apisix/admin-api/#route</span><span class="w">
</span><span class="w"></span>routers<span class="p">:</span><span class="w">
</span><span class="w">  </span>-<span class="w"> </span>id<span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">                     </span><span class="c"># 路由唯一标识</span><span class="w">
</span><span class="w">    </span>uri<span class="p">:</span><span class="w"> </span>/<span class="w">                    </span><span class="c"># 路由匹配的URI</span><span class="w">
</span><span class="w">    </span>host<span class="p">:</span><span class="w"> </span>www.baidu.com<span class="w">       </span><span class="c"># 匹配的主机</span><span class="w">
</span><span class="w">    </span><span class="c"># 可选项：</span><span class="w">
</span><span class="w">    </span><span class="c"># uris: [&#34;/&#34;,&#34;/test&#34;]     # 支持多个URI匹配</span><span class="w">
</span><span class="w">    </span><span class="c"># hosts: [&#34;www.baidu.com&#34;,&#34;www.taobao.com&#34;] # 支持多个Host匹配</span><span class="w">
</span><span class="w">    </span><span class="c"># methods: [&#34;GET&#34;, &#34;POST&#34;] # 限制请求方法</span><span class="w">
</span><span class="w">    </span><span class="c"># timeout:</span><span class="w">
</span><span class="w">    </span><span class="c">#   connect: 2           # 连接超时时间（秒）</span><span class="w">
</span><span class="w">    </span><span class="c">#   send: 3              # 发送超时时间（秒）</span><span class="w">
</span><span class="w">    </span><span class="c">#   read: 5              # 读取超时时间（秒）</span><span class="w">
</span><span class="w">    </span><span class="c"># priority: 10           # 路由优先级（数字越大，优先级越高）</span><span class="w">
</span><span class="w">    </span>upstream<span class="p">:</span><span class="w">                </span><span class="c"># 定义后端服务</span><span class="w">
</span><span class="w">      </span>nodes<span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="s2">&#34;www.baidu.com&#34;</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">   </span><span class="c"># 后端服务地址及权重</span><span class="w">
</span><span class="w">      </span>type<span class="p">:</span><span class="w"> </span>roundrobin<span class="w">       </span><span class="c"># 负载均衡类型（支持roundrobin、random等）</span><span class="w">
</span><span class="w">      </span>checks<span class="p">:</span><span class="w">                </span><span class="c"># 健康检查配置</span><span class="w">
</span><span class="w">        </span>active<span class="p">:</span><span class="w">              </span><span class="c"># 主动健康检查</span><span class="w">
</span><span class="w">          </span>type<span class="p">:</span><span class="w"> </span>https<span class="w">        </span><span class="c"># 检查类型（http/https）</span><span class="w">
</span><span class="w">          </span>timeout<span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">         </span><span class="c"># 健康检查超时时间（秒）</span><span class="w">
</span><span class="w">          </span>host<span class="p">:</span><span class="w"> </span>www.baidu.com<span class="w"> </span><span class="c"># 检查目标主机</span><span class="w">
</span><span class="w">          </span>http_path<span class="p">:</span><span class="w"> </span>/<span class="w">       </span><span class="c"># 健康检查路径</span><span class="w">
</span><span class="w">          </span>https_verify_certificate<span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="c"># 是否验证HTTPS证书</span><span class="w">
</span><span class="w">          </span>req_headers<span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&#34;User-Agent: curl/7.29.0&#34;</span><span class="p">]</span><span class="w"> </span><span class="c"># 请求头</span><span class="w">
</span><span class="w">          </span>healthy<span class="p">:</span><span class="w">           </span><span class="c"># 健康服务的标准</span><span class="w">
</span><span class="w">            </span>interval<span class="p">:</span><span class="w"> </span><span class="m">5</span><span class="w">      </span><span class="c"># 健康检查间隔时间（秒）</span><span class="w">
</span><span class="w">            </span>http_statuses<span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="m">200</span><span class="p">,</span><span class="w"> </span><span class="m">201</span><span class="p">]</span><span class="w"> </span><span class="c"># 判断健康的HTTP状态码</span><span class="w">
</span><span class="w">            </span>successes<span class="p">:</span><span class="w"> </span><span class="m">2</span><span class="w">     </span><span class="c"># 连续成功次数</span><span class="w">
</span><span class="w">          </span>unhealthy<span class="p">:</span><span class="w">         </span><span class="c"># 不健康服务的标准</span><span class="w">
</span><span class="w">            </span>http_failures<span class="p">:</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="c"># 连续失败的HTTP请求次数</span><span class="w">
</span><span class="w">            </span>tcp_failures<span class="p">:</span><span class="w"> </span><span class="m">2</span><span class="w">  </span><span class="c"># 连续失败的TCP请求次数</span><span class="w">
</span><span class="w">      </span>pass_host<span class="p">:</span><span class="w"> </span>rewrite<span class="w">     </span><span class="c"># 是否透传主机信息</span><span class="w">
</span><span class="w">      </span>upstream_host<span class="p">:</span><span class="w"> </span>www.baidu.com<span class="w"> </span><span class="c"># 传递给后端的Host</span><span class="w">
</span><span class="w">      </span>scheme<span class="p">:</span><span class="w"> </span>https<span class="w">          </span><span class="c"># 使用的协议（http/https）</span></code></pre></div>
<p><strong>说明</strong>：
- <strong>Router</strong> 定义了请求的路由规则，目前支持 <code>uri</code> 和 <code>host</code> 的匹配，还可以扩展支持 <code>methods</code>、<code>priority</code> 等参数。
- <strong>Upstream</strong> 配置支持负载均衡和健康检查，支持配置各种复杂均衡算法，还支持主动健康检查。</p>

<p>可以在 <a href="https://github.com/zhu327/pingsix/blob/main/config.yaml">GitHub</a> 查看完整的配置文件。</p>

<hr />

<h4 id="4-配置加载">4. 配置加载</h4>

<p>在 pingsix 中，配置加载的实现方式与 Pingora 完全兼容，主要通过复用 Pingora 的命令行解析和配置加载代码来完成。这些代码大部分是直接借鉴了 Pingora 的实现，并根据 pingsix 的需求做了一些简单的调整和优化。</p>

<h5 id="主要改进">主要改进：</h5>

<ol>
<li><strong>使用 <code>serde</code> 进行配置解析</strong>：配置文件仍然采用 YAML 格式，使用 <code>serde_yaml</code> 库进行解析。</li>
<li><strong>配置校验</strong>：为了确保配置的正确性，我们引入了 <code>validator</code> crate，对配置项进行简单的校验，确保它们符合预期。</li>
<li><strong>默认值和拷贝</strong>：通过 <code>serde</code> 的 <code>default</code> 特性简化了默认值的处理，使用 <code>Clone</code> derive 特性实现了配置的拷贝。</li>
</ol>

<h5 id="配置加载实现">配置加载实现</h5>

<p>配置的加载流程和 Pingora 基本一致，代码结构也与 Pingora 相似。我们首先读取 YAML 配置文件，然后通过 <code>serde_yaml</code> 进行解析，最后使用 <code>validator</code> 校验配置项的合法性。</p>

<p>具体的实现可以参考 <a href="https://github.com/zhu327/pingsix/blob/main/src/config/mod.rs">pingsix 的配置加载代码</a>，该文件展示了配置解析、校验和默认值处理的实现方式。</p>

<h3 id="实现-上游">实现：上游</h3>

<p>从 APISix 的上游配置功能可以看出，网关的上游模块需要具备以下核心功能：</p>

<ol>
<li><strong>DNS 解析</strong>：支持上游服务的域名解析。</li>
<li><strong>负载均衡算法</strong>：支持多种负载均衡算法和自定义 hash key。</li>
<li><strong>健康检查</strong>：实现主动健康检查，确保上游服务的可用性。</li>
<li><strong>超时与重试配置</strong>：为连接、发送和读取设置超时时间，并在请求失败时进行重试。</li>
<li><strong>协议支持</strong>：支持 HTTP 和 HTTPS 上游协议。</li>
</ol>

<h4 id="上游模块实现结构">上游模块实现结构</h4>

<p>根据 Pingora 的抽象设计，我们将上游处理拆分为两个主要模块，分别负责服务发现和负载均衡：</p>

<ol>
<li><p><strong>服务发现模块</strong><br />
服务发现模块位于 <code>discovery.rs</code>，支持静态 IP 配置、域名 DNS 解析，并允许 HTTP/HTTPS 混合配置。详情见 <a href="https://github.com/zhu327/pingsix/blob/main/src/proxy/discovery.rs">discovery.rs 源码</a>。</p></li>

<li><p><strong>负载均衡模块</strong><br />
负载均衡模块位于 <code>lb.rs</code>，支持 roundrobin、random、fnvhash 和 ketama 等算法，并按照 APISix 实现了部分基于 <code>vars</code>、<code>header</code> 和 <code>cookie</code> 的 hash 计算。负载均衡模块可扩展不同的 hash key 类型。更多实现细节见 <a href="https://github.com/zhu327/pingsix/blob/main/src/proxy/lb.rs">lb.rs 源码</a>。</p></li>
</ol>

<h4 id="实现心得">实现心得</h4>

<ol>
<li><p><strong>多态设计</strong>：通过 <code>enum</code> 实现负载均衡算法的多态性，将不同算法的差异封装在模块内，便于调用和扩展。</p></li>

<li><p><strong>配置转换简化</strong>：使用 <code>From</code> trait 将配置结构转换为业务对象，简化代码，提高可读性。</p></li>

<li><p><strong>健康检查集成</strong>：Pingora 的健康检查逻辑与上游绑定在一起，而健康检查后台服务需要在 server 启动时注入。因此，我们在上层结构中将上游和健康检查逻辑绑定，通过 <code>Option</code> 灵活控制其生命周期。</p></li>
</ol>

<p>以上实现方法确保了代码结构的简洁性和模块的可复用性，建议阅读相关源码进一步了解实现细节。</p>

<h3 id="实现-路由">实现：路由</h3>

<p>路由模块参考了 <a href="https://github.com/apache/apisix/tree/master/apisix/http/router">APISix 的 radixtree_host_uri 路由方式</a>，通过 <code>host</code> 和 <code>uri</code> 的组合实现高效的路由匹配。</p>

<p>在 pingsix 中，我们使用了 Rust 的 <code>matchit</code> crate，这是一个高性能的 Radix Tree 路由库，用来实现与 APISix 相同的功能。<code>matchit</code> 提供了灵活的路由匹配能力，支持精确匹配和通配符规则。</p>

<p>此外，路由逻辑还结合了负载均衡（lb）模块的方法，实现请求的精准路由，并支持通过路由的 <code>timeout</code> 配置覆盖默认的上游超时设置。</p>

<p>完整实现可以参考 <a href="https://github.com/zhu327/pingsix/blob/main/src/proxy/router.rs">router.rs 源码</a>。</p>

<h3 id="实现-pingora-service-与-server">实现：Pingora Service 与 Server</h3>

<h4 id="service-实现">Service 实现</h4>

<p>Pingora 的 <code>Service</code> 概念用于定义 HTTP 请求处理的各个阶段，其处理流程与 Nginx 的处理阶段类似（参考 <a href="https://github.com/cloudflare/pingora/blob/main/docs/user_guide/phase.md">Pingora 的阶段设计</a>）。在 pingsix 中，通过实现 <code>ProxyService</code> trait，可以构建一个完整的反向代理服务，并在以下阶段插入自定义逻辑：</p>

<ul>
<li><strong>request</strong>: 请求接收后可进行修改或校验。<br /></li>
<li><strong>upstream_request</strong>: 转发到上游前处理请求。<br /></li>
<li><strong>upstream_response</strong>: 接收上游响应后进行处理。<br /></li>
<li><strong>response</strong>: 返回客户端前对响应进行最终修改。</li>
</ul>

<p>这种设计让我们可以通过插件灵活扩展功能，例如添加认证、流量控制等。核心代码实现可参考 <a href="https://github.com/cloudflare/pingora/blob/main/src/mod.rs">pingsix proxy 模块</a>。</p>

<h4 id="server-实现">Server 实现</h4>

<p>Server 层负责协调配置、路由和服务启动等核心功能：</p>

<ol>
<li><p><strong>加载配置与路由</strong><br />
从配置文件中加载路由规则和监听地址，并初始化所需的服务模块。</p></li>

<li><p><strong>启动监听器</strong><br />
支持多协议监听（如 HTTP/HTTPS），并动态绑定配置的监听端口。</p></li>

<li><p><strong>Service 扩展</strong><br />
在 Server 中可以注册多种 <code>Service</code> 实现：</p>

<ul>
<li><code>ProxyService</code>: 用于处理反向代理逻辑。<br /></li>
<li><code>BackgroundService</code>: 如健康检查后台任务。<br /></li>
<li>自定义扩展 Service，例如自动申请证书等。</li>
</ul></li>
</ol>

<p>通过这种设计，Server 可以灵活地管理多个服务实例，扩展功能变得简单且直观。完整的实现代码可参考 <a href="https://github.com/zhu327/pingsix/blob/main/src/main.rs">pingsix 的 main.rs</a>。</p>

<h3 id="规划">规划</h3>

<p>接下来，我们将基于当前的反向代理功能进一步完善 API 网关的核心扩展能力，规划包括：</p>

<ol>
<li><p><strong>插件支持</strong><br />
引入插件机制，支持动态加载和执行，逐步实现 API 网关的关键插件（如认证、限流、日志等），提升功能的灵活性与可扩展性。</p></li>

<li><p><strong>动态配置管理</strong><br />
集成 etcd，实现配置的动态加载和更新，以便在无需重启服务的情况下动态调整路由、上游配置等。</p></li>

<li><p><strong>上游与服务的独立配置</strong><br />
提供上游（upstream）和服务（service）的单独配置抽象，使得复杂业务需求下的配置更清晰、模块化。</p></li>
</ol>

<hr />

<p>经过以上设计，我们已经构建了一个完整的基础反向代理功能，但要实现 API 网关的核心价值，接下来的重点将聚焦在插件系统的设计与实现，以便支持更丰富的功能扩展。</p>

<h3 id="参考">参考</h3>

<ul>
<li><a href="https://github.com/apache/apisix">APISix</a> - 开源、高性能的 API 网关，提供丰富的插件支持和灵活的配置管理。</li>
<li><a href="https://github.com/cloudflare/pingora">Pingora</a> - Cloudflare 开发的高性能反向代理，采用 Rust 实现，设计灵感来源于 Nginx。</li>
</ul>

<p>其他相关项目：</p>

<ul>
<li><a href="https://github.com/vicanso/pingap">pingap</a> - 一个使用 Rust 实现的轻量级 API 网关，适合参考其架构和插件设计。</li>
<li><a href="https://github.com/memorysafety/river">river</a> - Rust 实现的分布式流量管理系统，支持动态路由和负载均衡功能。</li>
<li><a href="https://github.com/caibirdme/penguin">penguin</a> - Rust 编写的反向代理服务器，用于学习和参考其路由与负载均衡实现。</li>
</ul>


</div>



<script src="https://utteranc.es/client.js"
  repo="zhu327/zhu327.github.io"
  issue-term="title"
  theme="github-light"
  crossorigin="anonymous"
  async>
</script>


      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

  </body>
</html>

