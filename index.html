<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
	<meta name="generator" content="Hugo 0.40.1" />
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      跬步 &middot; On Coding
    
  </title>

  
  <link rel="stylesheet" href="https://zhu327.github.io/css/poole.css">
  <link rel="stylesheet" href="https://zhu327.github.io/css/syntax.css">
  <link rel="stylesheet" href="https://zhu327.github.io/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://zhu327.github.io/assets/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="https://zhu327.github.io/assets/favicon.ico">

  
  <link rel="alternate" type="application/rss+xml" title="RSS" href="https://zhu327.github.io/feed.xml">
</head>


  <body class="theme-base-0d">

    
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">


<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>My notes and thoughts.</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item  active " href="https://zhu327.github.io/">Home</a>
    <a class="sidebar-nav-item " href="https://zhu327.github.io/post">Posts</a>
    <a class="sidebar-nav-item " href="https://zhu327.github.io/tags">Tags</a>

    
        <a class="sidebar-nav-item " href="https://zhu327.github.io/about/">About</a>

    <a class="sidebar-nav-item" href="https://github.com/zhu327" target="_blank">GitHub</a>
  </nav>

  <div class="sidebar-item">
    <p>&copy; 2020. All rights reserved.</p>
  </div>
</div>


    
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="https://zhu327.github.io/" title="Home">跬步</a>
            <small>On Coding</small>
          </h3>
        </div>
      </div>

      <div class="container content">





<div class="posts">
  
    <div class="post">
        <h1 class="post-title"><a href="https://zhu327.github.io/2020/10/22/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/">领域驱动设计与微服务</a></h1>
        <span class="post-date">Oct 22 2020</span>
        DRF的起手式  CURD Boy的通常的工作模式   先设计Serializer还是先设计Model?  问题是什么  框架捆绑  写框架无关的代码  复杂的逻辑会陷入职责不清晰, 交叉依赖  抽象一层   面向对象 SOLID原则
   SRP The Single Responsibility Principle  单一责任原则     OCP The Open Closed Principle 开放封闭原则   LSP The Liskov Substitution Principle 里氏替换原则   DIP The Dependency Inversion Principle 依赖倒置原则   ISP The Interface Segregation Principle 接口分离原则    clean Architecture  实体: 模型, 比如权限中心的一条策略就是一个实体, 它具有唯一的ID  模型不是分散的, 与存储无关, 避免交叉依赖  用例: 业务的使用规则, 实例在某种场景下的使用方式, 一段实体的使用逻辑  与api无关, 只与业务逻辑相关  对外暴露接口与适配器  隐藏用例与实体, 只对外暴露接口  框架, 驱动  对接接口, 实现适配器接口    从业务出发, 以业务逻辑为核心构建系统 灵活的使用外部依赖, 扩展方便  六边形架构  以业务为核心, 外部依赖全部做成适配器, 方便替换  领域驱动设计 为解决复杂的现实问题的一种设计模式, 将数据和行为封装在一起，并与现实世界中的业务对象相映射。各类具备明确的职责划分，将领域逻辑分散到领域对象中。
    </div>
  
    <div class="post">
        <h1 class="post-title"><a href="https://zhu327.github.io/2020/05/07/%E8%AF%BB%E4%B9%A6%E6%96%B9%E6%B3%95%E8%AE%BA/">读书方法论</a></h1>
        <span class="post-date">May 7 2020</span>
        <p>从2017年决定补计算机基础开始, 至今已经读了50来本计算机书籍. 读书的时间总是很宝贵, 如何正确的读书呢? 下面是我的一些经验与总结.</p>

<h3 id="读书的目的">读书的目的</h3>

<p>我们读书的目的是什么? 概况起来可以分为以下2种:</p>

<ol>
<li>学习知识</li>
<li>提升自己的能力</li>
</ol>

<p>我们在上学时专注与学习知识, 所以书本上的每一部分我们都需要了解, 所以我们需要一遍一遍的读, 抓住书本种每一个知识点.</p>

<p>但是在工作后, 我们读书是为了解决问题, 提升自己的能力, 知识 != 能力, 工作后我们读书的主语不再是知识, 而是自己, 面向自己读书需要一些方法.</p>

<p></p>
    </div>
  
    <div class="post">
        <h1 class="post-title"><a href="https://zhu327.github.io/2019/12/22/%E4%BB%8Epython%E5%88%B0golang/">从Python到Golang</a></h1>
        <span class="post-date">Dec 22 2019</span>
        <p>是的, 从去年底开始, 我差不多写Golang一年了, 从最开始的视频流处理, 到Websocket远程控制, 再到现在写的高性能鉴权中间件. 为什么不用Python? 因为Python满足不了长连接或者高性能的需求. 为什么不用其它语言? 大概是因为Golang足够<code>简单</code>吧. 这里分享下这一年多写Golang相对于Python的一些感想.</p>

<h3 id="强类型">强类型</h3>

<h4 id="代码检查">代码检查</h4>

<p>Golang是强类型语言, 配合IDE, Lint, 编译工具, 一些常见的, 马马虎虎的写代码的低级错误在代码提交之前就能被检测出来. 虽然Python也有flak8, 但是相对于Golang犯低级错误的可能性更大些, 特别是对于没有单元测试的代码(是的, 单元测试不是每个团队都会做的).</p>

<p></p>
    </div>
  
    <div class="post">
        <h1 class="post-title"><a href="https://zhu327.github.io/2018/08/29/gunicorn%E4%B8%8Euwsgi%E4%B9%8B%E6%88%91%E8%A7%81/">Gunicorn与uWSGI之我见</a></h1>
        <span class="post-date">Aug 29 2018</span>
        <p>昨天前同事问我<a href="https://github.com/zhu327/doge">doge</a>的服务端怎么是单进程跑的, 其实在生产环境下我们参考<a href="https://github.com/eleme/gunicorn_thrift">gunicorn_thrift</a>实现了一个定制的master/worker模型的Gunicorn服务器. 昨天也写了一个<a href="https://github.com/zhu327/doge/tree/master/doge/gunicorn">简化版本</a>集成到doge, 实际代码不超过20行就能利用到Gunicorn的进程管理功能. 有感于Gunicorn简洁优雅的模型, 这里聊聊我理解的Gunicorn与uWSGI.</p>

<h2 id="perfork">perfork</h2>

<p>perfork是一种服务端编程模型, Nginx, Gunicorn, uWSGI都是这种模型的实现, 简单的说perfok就是master进程启动注册一堆信号处理函数, 创建listen socket fd, fork出多个worker子进程, 子进程执行accept循环处理请求(这里简化模型, 当然也可以用select, epoll多路复用), master进程只负责监控worker进程状态, 通过pipeline通信来控制worker进程.</p>

<p></p>
    </div>
  
    <div class="post">
        <h1 class="post-title"><a href="https://zhu327.github.io/2018/07/19/python%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/">Python后端架构演进</a></h1>
        <span class="post-date">Jul 19 2018</span>
        <p>来腾讯之前在前公司做了3年的后端开发, 经历一款SaaS产品从0到10(还没有到100, 哈哈哈)的过程, 3年间后端的架构逐步演变, 在微服务的实践过程中遇到的问题也越来越多, 在这里总结下.</p>

<p>产品是一款服务于人力资源的SaaS在线服务, 面向HR有Web Android/iOS 小程序多个客户端, 后端采用RESTful风格API来提供服务. 主要使用Python语言, 方便快速迭代.</p>

<p>架构的演进经历了4个大的阶段: 1. MVC 2. 服务拆分 3. 微服务架构 4. 领域驱动设计.</p>

<p></p>
    </div>
  
</div>

<div class="pagination">
  
  <a class="pagination-item older" href="https://zhu327.github.io/page/2/">Older</a>
  

  
  <span class="pagination-item newer">Newer</span>
  
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

  </body>
</html>

