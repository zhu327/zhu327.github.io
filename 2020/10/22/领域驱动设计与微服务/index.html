<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      领域驱动设计与微服务 &middot; 跬步
    
  </title>

  
  <link rel="stylesheet" href="https://zhu327.github.io/css/poole.css">
  <link rel="stylesheet" href="https://zhu327.github.io/css/syntax.css">
  <link rel="stylesheet" href="https://zhu327.github.io/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://zhu327.github.io/assets/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="https://zhu327.github.io/assets/favicon.ico">

  
  <link rel="alternate" type="application/rss+xml" title="RSS" href="https://zhu327.github.io/feed.xml">
</head>


  <body class="theme-base-0d">

    
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">


<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>My notes and thoughts.</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item " href="https://zhu327.github.io/">Home</a>
    <a class="sidebar-nav-item " href="https://zhu327.github.io/post">Posts</a>
    <a class="sidebar-nav-item " href="https://zhu327.github.io/tags">Tags</a>

    
        <a class="sidebar-nav-item " href="https://zhu327.github.io/about/">About</a>

    <a class="sidebar-nav-item" href="https://github.com/zhu327" target="_blank">GitHub</a>
  </nav>

  <div class="sidebar-item">
    <p>&copy; 2020. All rights reserved.</p>
  </div>
</div>


    
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="https://zhu327.github.io/" title="Home">跬步</a>
            <small>On Coding</small>
          </h3>
        </div>
      </div>

      <div class="container content">


<div class="post">
  <h1 class="post-title">领域驱动设计与微服务</h1>
  <span class="post-date">Oct 22 2020</span>
  <h3 id="drf的起手式">DRF的起手式</h3>

<ul>
<li>CURD Boy的通常的工作模式</li>
</ul>

<p><img src="https://blog-1251544432.cos.ap-guangzhou.myqcloud.com/blog/image-20201010162649717.png" alt="image-20201010162649717"  /></p>

<ul>
<li>先设计Serializer还是先设计Model?</li>
</ul>

<p></p>

<h3 id="问题是什么">问题是什么</h3>

<p><img src="https://blog-1251544432.cos.ap-guangzhou.myqcloud.com/blog/image-20201010162706372.png" alt="image-20201010162706372"  /></p>

<ul>
<li>框架捆绑

<ul>
<li>写框架无关的代码</li>
</ul></li>
<li>复杂的逻辑会陷入职责不清晰, 交叉依赖

<ul>
<li>抽象一层</li>
</ul></li>
</ul>

<h3 id="面向对象">面向对象</h3>

<p>SOLID原则</p>

<table>
<thead>
<tr>
<th><strong>SRP</strong></th>
<th><a href="http://www.objectmentor.com/resources/articles/srp.pdf">The Single Responsibility Principle </a></th>
<th>单一责任原则</th>
</tr>
</thead>

<tbody>
<tr>
<td><strong>OCP</strong></td>
<td><a href="http://www.objectmentor.com/resources/articles/ocp.pdf">The Open Closed Principle</a></td>
<td>开放封闭原则</td>
</tr>

<tr>
<td><strong>LSP</strong></td>
<td><a href="http://www.objectmentor.com/resources/articles/lsp.pdf">The Liskov Substitution Principle</a></td>
<td>里氏替换原则</td>
</tr>

<tr>
<td><strong>DIP</strong></td>
<td><a href="http://www.objectmentor.com/resources/articles/dip.pdf">The Dependency Inversion Principle</a></td>
<td>依赖倒置原则</td>
</tr>

<tr>
<td><strong>ISP</strong></td>
<td><a href="http://www.objectmentor.com/resources/articles/isp.pdf">The Interface Segregation Principle</a></td>
<td>接口分离原则</td>
</tr>
</tbody>
</table>

<h3 id="clean-architecture">clean Architecture</h3>

<p><img src="http://zhixinliu.com/images/201507-CleanArchitecture.jpg" alt=" " style="zoom:80%;" /></p>

<ul>
<li>实体: 模型, 比如权限中心的一条策略就是一个实体, 它具有唯一的ID

<ul>
<li>模型不是分散的, 与存储无关, 避免交叉依赖</li>
</ul></li>
<li>用例: 业务的使用规则, 实例在某种场景下的使用方式, 一段实体的使用逻辑

<ul>
<li>与api无关, 只与业务逻辑相关</li>
</ul></li>
<li>对外暴露接口与适配器

<ul>
<li>隐藏用例与实体, 只对外暴露接口</li>
</ul></li>
<li>框架, 驱动

<ul>
<li>对接接口, 实现适配器接口</li>
</ul></li>
</ul>

<hr />

<ul>
<li>从业务出发, 以业务逻辑为核心构建系统</li>
<li>灵活的使用外部依赖, 扩展方便</li>
</ul>

<h3 id="六边形架构">六边形架构</h3>

<p><img src="http://insights.thoughtworkers.org/wp-content/uploads/2017/06/3-application.jpg" alt="img" style="zoom: 80%;" /></p>

<ul>
<li>以业务为核心, 外部依赖全部做成适配器, 方便替换</li>
</ul>

<h3 id="领域驱动设计">领域驱动设计</h3>

<p>为解决复杂的现实问题的一种设计模式, 将数据和行为封装在一起，并与现实世界中的业务对象相映射。各类具备明确的职责划分，将领域逻辑分散到领域对象中。</p>

<ul>
<li>业务架构——根据业务需求设计业务模块及其关系</li>
<li>系统架构——设计系统和子系统的模块</li>
<li>技术架构——决定采用的技术及框架</li>
</ul>

<p>DDD的核心诉求就是将业务架构映射到系统架构上，在响应业务变化调整业务架构时，也随之变化系统架构。</p>

<h3 id="什么是领域">什么是领域</h3>

<p>在互联网兴起之前, 传统的软件行业, 做的软件都是在解决现实中已经存在的问题, 软件的意义在于提示现实问题处理的效率, 比如电子商务, 现实中的商务模式只怎样运转的, 电子商务就是怎样运转的, 软件系统的意义在于大大提升了商务模式的运转的效率, 所以要设计一个好的软件系统, 先要有足够的领域知识, 以现实中出现的问题为基础, 构建领域的模型</p>

<p>已订单模型为例, 同样是订单, 对于购买客户展示的订单与对商户展示的订单信息就不一样, 操作也不一样, 这就需要对模型进行域的划分, 分别分为客户域与商户域</p>

<p><img src="https://blog-1251544432.cos.ap-guangzhou.myqcloud.com/blog/image-20201010170636576.png" alt="image-20201010170636576"  /></p>

<h3 id="领域语言">领域语言</h3>

<p>定义术语, 识别出领域内的用例主谓宾, 主语: 实体, 谓语: 用例, 宾语: 值对象, 比如在权限中心, 管理员对用户授权了xx权限</p>

<h3 id="领域模型-entry与valueobject">领域模型 &ndash; Entry与ValueObject</h3>

<p><img src="http://www.cosmicpython.com/book/images/apwp_0104.png" alt="apwp 0104" style="zoom: 50%;" /></p>

<p><strong>实体</strong></p>

<p>当一个对象由其标识（而不是属性）区分时，这种对象称为实体（Entity）。</p>

<p>在权限中心, 用户, 管理员, 策略, 都有唯一的标志, 可以分门别类划分到各自域的实体</p>

<p><strong>值对象</strong></p>

<p>当一个对象用于对事务进行描述而没有唯一标识时，它被称作值对象（Value Object）。</p>

<p>权限中心中, 策略中的拓扑, 属性, 这些没有唯一标志的值, 就是值对象</p>

<h3 id="repository">Repository</h3>

<p>数据存储的adapter, 以Entry为参数, 保存实体信息到存储引擎, 从数据库中加载数据为实体对象</p>

<p><img src="http://www.cosmicpython.com/book/images/apwp_0201.png" alt="apwp 0201" style="zoom:50%;" /></p>

<p>好处:</p>

<ul>
<li>简单的接口, 解耦了对存储的依赖</li>
<li>方便进行单元测试, 通过Facke Repository</li>
<li>开考虑如何存储数据前, 专注于解决业务问题, 使得模型更加贴合实际问题</li>
</ul>

<p>坏处:</p>

<ul>
<li>增加了额外的代码逻辑, 提高的维护的成本</li>
<li>有一些逻辑可能ORM框架就已经支持了</li>
</ul>

<h3 id="service">Service</h3>

<p>服务层, 领域模型的使用用例, 一些重要的领域行为或操作，可以归类为领域服务。它既不是实体，也不是值对象的范畴。</p>

<p><img src="http://www.cosmicpython.com/book/images/apwp_0402.png" alt="apwp 0402" style="zoom: 50%;" /></p>

<p>好处:</p>

<ol>
<li>提供一个单一的地方放所以的用例</li>
<li>通过服务层来把领域模型隐藏在api后面, 方便对领域层做重构</li>
<li>把定制http相关的协议改变成了定制服务的协议, 接口只是服务层的派生</li>
<li>有了存储层后, 可以方便的使用Fake存储来做测试</li>
</ol>

<p>坏处:</p>

<ol>
<li>如果你的app是一个纯粹的web服务, MVC就可很好的处理用例了, 不需要增加多余复杂度</li>
<li>服务层是另外的一个抽象</li>
<li>服务层承载了太多的逻辑, 会导致领域层成为贫血模式</li>
<li>在采用服务层前, 需要理清控制面上的逻辑编排</li>
<li>把控制面的逻辑下沉到领域模型上, 可以得到胖模型, 瘦控制</li>
</ol>

<h3 id="unit-of-work">Unit of Work</h3>

<p>service层中直接对接了Repository, 处理了太多事务相关的逻辑, 通过UOW来封装事务的处理</p>

<p><img src="http://www.cosmicpython.com/book/images/apwp_0602.png" alt="apwp 0602" style="zoom: 50%;" /></p>

<p>好处:</p>

<ol>
<li>对于原子操作有一个更好的抽象, 通过上下文管理器直观的看到哪些逻辑组合在一起</li>
<li>对事务的开始与结束有了明确的定义</li>
<li>提供了实例化存储类的地方</li>
<li>帮助处理事件与消息总线</li>
</ol>

<p>坏处:</p>

<ol>
<li>可能ORM已经有类似的封装</li>
<li>看起来简单, 但是还要处理回滚, 多线程, 嵌条事务等情况</li>
</ol>

<h3 id="aggregate">Aggregate</h3>

<p>Aggregate(聚合）是一组相关对象的集合，作为一个整体被外界访问，聚合根（Aggregate Root）是这个聚合的根节点。</p>

<p>有了Service与UOA后, 往往会导致Service的逻辑复杂, 而领域模型上的逻辑非常简单, 甚至于没有相关的方法, 这就是所谓的贫血模式/失血模式, 这时候就需要一种新的抽象来承载领域模型上的相关逻辑, Aggregate</p>

<p>以权限中心为例, 每次操作的Policy并不是一个, 而是一批, 这时候就可以定义PolicyAggregate, 来把批量的Policy操作的方法封装在聚合之中</p>

<p><img src="http://www.cosmicpython.com/book/images/apwp_0701.png" alt="apwp 0701" style="zoom:50%;" /></p>

<p>好处:</p>

<ol>
<li>聚会可以定义出哪些模型是可以暴露, 那些不暴露</li>
<li>显示的定义界限上下文, 有助于提高ORM性能</li>
<li>由聚合来负责状态的变更, 更容易控制内部数据, 提供统一的出入口</li>
</ol>

<p>坏处:</p>

<ol>
<li>对于新开发者不友好, 需要多理解一个概念</li>
<li>严格定义聚合的单一职责, 对于思维的考研很大</li>
<li>不同聚合之间数据的最终一致可能很麻烦</li>
</ol>

<h3 id="event-drive">Event Drive</h3>

<p>领域事件是对领域内发生的活动进行的建模。</p>

<p><img src="http://www.cosmicpython.com/book/images/apwp_0801.png" alt="apwp 0801" style="zoom:50%;" /></p>

<p>好处:</p>

<ol>
<li>消息总线解耦了不同逻辑之间的耦合, 通过响应消息实现多种逻辑的处理</li>
<li>时间响应的处理与核心的领域逻辑得到隔离</li>
<li>领域时间实际上是现实问题的一种抽象, 可以跟领域语言有机的结合到一起</li>
</ol>

<p>坏处:</p>

<ol>
<li>消息总线隔离各种逻辑, 不方便梳理整体逻辑</li>
<li>要小心消息的循环依赖</li>
</ol>

<p>完全的事件驱动</p>

<p><img src="http://www.cosmicpython.com/book/images/apwp_0902.png" alt="apwp 0902" style="zoom:50%;" /></p>

<p>好处:</p>

<ol>
<li>handler与service变成了一个, 架构简化</li>
<li>事件对于api与handle的参数传递提供统一的结构</li>
</ol>

<p>坏处:</p>

<ol>
<li>对于web服务来说, 消息总线不是一个可以感知的过程, 异步逻辑不知道什么时候完成</li>
<li>事件对象与模型对象存在大量相同的字段, 修改时也要同时修改</li>
</ol>

<p>引入命令模式:</p>

<p>好处:</p>

<ol>
<li>区分出命令与事件, 可以清晰的定义出哪些是必须完成的, 哪些是额外的逻辑</li>
<li>命令名称相对于事件更明确</li>
</ol>

<p>坏处:</p>

<ol>
<li>命令与事件语义上的差异可能很小, 要小心区分</li>
<li>明确的处理失败与异常, 使得影响变小, 逻辑更加难理解, 需要增加更多监控</li>
</ol>

<p>事件驱动的微服务:</p>

<p><img src="http://www.cosmicpython.com/book/images/apwp_1101.png" alt="apwp 1101" style="zoom:50%;" /></p>

<p>好处:</p>

<ol>
<li>避免依赖大泥球</li>
<li>分离服务: 更新与新增单个服务更简单</li>
</ol>

<p>坏处:</p>

<ol>
<li>整理流程的信息很难直观看出来</li>
<li>需要理解最终一致性</li>
<li>消息的可靠性需要权衡: 至少一次还是最多一次</li>
</ol>

<h3 id="cqrs">CQRS</h3>

<p><img src="http://www.cosmicpython.com/book/images/apwp_1201.png" alt="apwp 1201" style="zoom:50%;" /></p>

<p>命令于查询分离</p>

<table>
<thead>
<tr>
<th></th>
<th>查询</th>
<th>命令</th>
</tr>
</thead>

<tbody>
<tr>
<td>行为</td>
<td>简单</td>
<td>负责业务逻辑</td>
</tr>

<tr>
<td>缓存</td>
<td>可缓存</td>
<td>不可缓存</td>
</tr>

<tr>
<td>一致性</td>
<td>可能延迟</td>
<td>事务一致</td>
</tr>
</tbody>
</table>

<h3 id="微服务">微服务</h3>

<h3 id="宏服务的问题">宏服务的问题</h3>

<ol>
<li><p>代码量变大: 模块之间没有严格的界限, 想要理解系统整体困难, 随着代码的增加复杂度增加, 变更的成本变高, 降低迭代速度</p></li>

<li><p>资源利用低效: 整体服务占用大量的内存, 不管其中模块是否被大量的使用, 占用所有的数据库连接, 不管有没有使用</p></li>

<li><p>带来可扩展的问题: 即使能实现横向的扩展, 但是开发的过程中由于团队的人员变多, 也会带来版本迭代上的冲突, 除非有很好的职责划分, 不同团队之间的沟通, 会带来效率的降低</p></li>

<li><p>部署困难: 每次部署都需要保证所有模块的正确性, 其中某个模块出问题, 会导致整个系统的崩溃</p></li>

<li><p>技术的限制: 在选定一种技术后, 整个系统的技术就被限制了, 比如Python, 想要更改会非常困难</p></li>

<li><p>bug影响: 一个模块的bug可能会影响到整个系统, 一个模块的资源占用过多, 也会影响到整个系统</p></li>
</ol>

<h3 id="微服务-1">微服务</h3>

<ol>
<li><p>模块之间松耦合</p></li>

<li><p>独立部署</p></li>

<li><p>每个微服务互相通信</p></li>

<li><p>为了提供整体的服务, 需要把微服务暴露成一个整体, 微服务隐藏在整体后面</p></li>
</ol>

<p>优点:</p>

<ol>
<li><p>微服务之间使用统一的通信协议通信, http-json, 更加通用一些, rpc更加高效</p></li>

<li><p>更好的资源利用率, 每个服务都是可控的, 按需分配资源</p></li>

<li><p>每个微服务都很小, 代码量少更简单, 重构更方便, 可以选择不同的技术栈</p></li>

<li><p>某些服务可以隐藏在微服务后面, 不对外提供, 更加安全</p></li>

<li><p>由于系统的独立, 一个服务的崩溃不会导致整体的崩溃</p></li>

<li><p>每个服务都是独立维护, 提高团队的开发效率</p></li>
</ol>

<p>缺点:</p>

<ol>
<li><p>迁移到微服务很困难, 需要付出大量的开发成本, 初期会带来很多混乱</p></li>

<li><p>微服务的会带来组织架构上的调整, 而一般公司的组织架构是很难改变的, 就会导致职责的分不清</p></li>

<li><p>学习曲线陡峭, 开发人员需要学习相关的开发模式, 需要开发运维相关的培训</p></li>

<li><p>调试更加困难</p></li>

<li><p>划分微服务本身很困难, 需要警惕多个独立服务合并到一个服务中, 这样就偏离的迁移微服务的初衷</p></li>

<li><p>违法对于团队配合会带来困难, 不同的团队会站在自己的角度思考, 沟通协调需要付出更多的成本</p></li>

<li><p>在整体功能与每个微服务的功能之间需要做平衡, 没有很好的配合, 团队之间会出现信息孤岛, 重复造轮子. 应该共享知识, 共享经验</p></li>

<li><p>敏捷开发的同时, 需要各个团队落地的文档就有要求了, 可以减少沟通, 但是增加额外的工作量</p></li>

<li><p>如果有对其它服务的依赖, 会增加请求的响应时间</p></li>
</ol>

<h3 id="总结">总结</h3>

<p>没有银弹, 没有完美的技术, 只有合适的技术.</p>


</div>



<span id="/2020/10/22/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="leancloud_visitors" data-flag-title="领域驱动设计与微服务">
  <span class="post-meta-item-text">文章阅读量 </span>
  <span class="leancloud-visitors-count">1000000</span>
  <p></p>
</span>
<div id="vcomments"></div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script type="text/javascript">
  new Valine({
      el: '#vcomments' ,
      appId: 'ets5MnLq4PcezyQ5V12Rn2yc-gzGzoHsz',
      appKey: '0PRGA047aMY95OeydaayLDEK',
      verify:  false , 
      avatar:'mm', 
      placeholder: '说点什么吧...',
      visitor:  true 
  });
</script>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

  </body>
</html>

