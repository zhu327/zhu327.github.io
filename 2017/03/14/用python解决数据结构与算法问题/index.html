<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      用Python解决数据结构与算法问题 &middot; 跬步
    
  </title>

  
  <link rel="stylesheet" href="https://zhu327.github.io/css/poole.css">
  <link rel="stylesheet" href="https://zhu327.github.io/css/syntax.css">
  <link rel="stylesheet" href="https://zhu327.github.io/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://zhu327.github.io/assets/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="https://zhu327.github.io/assets/favicon.ico">

  
  <link rel="alternate" type="application/rss+xml" title="RSS" href="https://zhu327.github.io/feed.xml">
</head>


  <body class="theme-base-0d">

    
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">


<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>My notes and thoughts.</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item " href="https://zhu327.github.io/">Home</a>
    <a class="sidebar-nav-item " href="https://zhu327.github.io/post">Posts</a>
    <a class="sidebar-nav-item " href="https://zhu327.github.io/tags">Tags</a>

    
    
      
        <a class="sidebar-nav-item " href="https://zhu327.github.io/about/">About</a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    <a class="sidebar-nav-item" href="https://github.com/zhu327" target="_blank">GitHub</a>
  </nav>

  <div class="sidebar-item">
    <p>&copy; 2020. All rights reserved.</p>
  </div>
</div>


    
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="https://zhu327.github.io/" title="Home">跬步</a>
            <small>On Coding</small>
          </h3>
        </div>
      </div>

      <div class="container content">


<div class="post">
  <h1 class="post-title">用Python解决数据结构与算法问题</h1>
  <span class="post-date">Mar 14 2017</span>
  <blockquote>
<p><a href="https://facert.gitbooks.io/python-data-structure-cn/">用Python解决数据结构与算法问题</a></p>
</blockquote>

<p>发现一本Python的好书被翻译了，利用下班时间学习了一下，把相关代码都实现了一遍，包括：</p>

<ul>
<li>栈，队列，双端队列</li>
<li>无序链表，有序链表</li>
<li>二叉树，堆，二叉搜索树，AVL树</li>
<li>图</li>
</ul>

<p>以及一些算法</p>

<p></p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># coding: utf-8</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">线性数据结构, 栈, 队列, deques, 容器结构, 数据项之间存在相对的位置
</span><span class="s2">&#34;&#34;&#34;</span>

<span class="k">class</span> <span class="nc">Stack</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">    栈 先进后出
</span><span class="s2">    &#34;&#34;&#34;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="c1"># O(1)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># O(1)</span>

    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span> <span class="o">==</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">)</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">全括号匹配
</span><span class="s2">((()))
</span><span class="s2">()(())()
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">parChecker</span><span class="p">(</span><span class="n">symbolString</span><span class="p">):</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">()</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbolString</span><span class="p">):</span>
        <span class="n">sym</span> <span class="o">=</span> <span class="n">symbolString</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">sym</span> <span class="o">==</span> <span class="s1">&#39;(&#39;</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">stack</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">stack</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">():</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">代码括号匹配
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">codeChecker</span><span class="p">(</span><span class="n">symbolString</span><span class="p">):</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">()</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbolString</span><span class="p">):</span>
        <span class="n">sym</span> <span class="o">=</span> <span class="n">symbolString</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">sym</span> <span class="ow">in</span> <span class="s1">&#39;([{&#39;</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">sym</span> <span class="ow">in</span> <span class="s1">&#39;)]}&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">stack</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">matches</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">sym</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">False</span>

        <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">stack</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">():</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>

<span class="k">def</span> <span class="nf">matches</span><span class="p">(</span><span class="nb">open</span><span class="p">,</span> <span class="n">close</span><span class="p">):</span>
    <span class="n">opens</span> <span class="o">=</span> <span class="s1">&#39;([{&#39;</span>
    <span class="n">closes</span> <span class="o">=</span> <span class="s1">&#39;)]}&#39;</span>
    <span class="k">return</span> <span class="n">opens</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">open</span><span class="p">)</span> <span class="o">==</span> <span class="n">closes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">close</span><span class="p">)</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">任意进制转换
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">baseConverter</span><span class="p">(</span><span class="n">decNumber</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
    <span class="n">digits</span> <span class="o">=</span> <span class="s1">&#39;0123456789ABCDEF&#39;</span>

    <span class="n">stack</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">()</span>

    <span class="k">while</span> <span class="n">decNumber</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">digits</span><span class="p">[</span><span class="n">decNumber</span> <span class="o">%</span> <span class="n">base</span><span class="p">])</span>
        <span class="n">decNumber</span> <span class="o">=</span> <span class="n">decNumber</span> <span class="o">//</span> <span class="n">base</span>

    <span class="n">string</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">stack</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">():</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">string</span>


<span class="k">class</span> <span class="nc">Queue</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">    队列 先进先出
</span><span class="s2">    &#34;&#34;&#34;</span>
    <span class="k">def</span> <span class="nf">__init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span> <span class="o">==</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">enqueue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="c1"># O(n)</span>

    <span class="k">def</span> <span class="nf">dequeue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># O(1)</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">烫手山芋 循环传递n次 淘汰一个 直到最后幸存一个
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">hotPotato</span><span class="p">(</span><span class="n">namelist</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">namelist</span><span class="p">:</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">queue</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">dequeue</span><span class="p">())</span>

        <span class="n">queue</span><span class="o">.</span><span class="n">dequeue</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">queue</span><span class="o">.</span><span class="n">dequeue</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">Deque</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">    双端队列 可以同时从2端 进出
</span><span class="s2">    &#34;&#34;&#34;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span> <span class="o">==</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">addFront</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="c1"># O(n)</span>

    <span class="k">def</span> <span class="nf">removeFront</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># O(n)</span>

    <span class="k">def</span> <span class="nf">addRear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="c1"># O(1)</span>

    <span class="k">def</span> <span class="nf">removeRear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># O(1)</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">回文检查 字符串前后一致
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">palchecker</span><span class="p">(</span><span class="n">aString</span><span class="p">):</span>
    <span class="n">deque</span> <span class="o">=</span> <span class="n">Deque</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">aString</span><span class="p">:</span>
        <span class="n">deque</span><span class="o">.</span><span class="n">addRear</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">deque</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">deque</span><span class="o">.</span><span class="n">removeFront</span><span class="p">()</span> <span class="o">!=</span> <span class="n">deque</span><span class="o">.</span><span class="n">removeRear</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">链表 节点包含数据本身，并保存指向下一个节点的指针
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initdata</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">initdata</span>
        <span class="bp">self</span><span class="o">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">getData</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

    <span class="k">def</span> <span class="nf">getNext</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="nb">next</span>

    <span class="k">def</span> <span class="nf">setData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">setNext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">无序链表
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">class</span> <span class="nc">UnorderedList</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># O(1)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span> <span class="c1"># O(1)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="n">node</span><span class="o">.</span><span class="n">setNext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">node</span>

    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># 遍历链 O(n)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">getNext</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">count</span>

    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span> <span class="c1"># O(n)</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">getData</span><span class="p">()</span> <span class="o">==</span> <span class="n">item</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">getNext</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span> <span class="c1"># O(n)</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">getData</span><span class="p">()</span> <span class="o">==</span> <span class="n">item</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">previous</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">getNext</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">previous</span><span class="o">.</span><span class="n">setNext</span><span class="p">(</span><span class="n">current</span><span class="o">.</span><span class="n">getNext</span><span class="p">())</span>
                <span class="k">return</span>
            <span class="n">previous</span> <span class="o">=</span> <span class="n">current</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">getNext</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span> <span class="c1"># O(n)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">node</span>
            <span class="k">return</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
        <span class="k">while</span> <span class="n">current</span><span class="o">.</span><span class="n">getNext</span><span class="p">():</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">getNext</span><span class="p">()</span>
        <span class="n">current</span><span class="o">.</span><span class="n">setNext</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span> <span class="c1"># O(n)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">getData</span><span class="p">()</span> <span class="o">==</span> <span class="n">item</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">count</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">getNext</span><span class="p">()</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span> <span class="c1"># O(k)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
            <span class="n">previous</span> <span class="o">=</span> <span class="n">current</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">getNext</span><span class="p">()</span>

        <span class="n">node</span><span class="o">.</span><span class="n">setNext</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">previous</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">previous</span><span class="o">.</span><span class="n">setNext</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>  <span class="c1"># O(n)</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">current</span><span class="o">.</span><span class="n">getNext</span><span class="p">():</span>
                <span class="n">previous</span> <span class="o">=</span> <span class="n">current</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">getNext</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
                <span class="n">previous</span> <span class="o">=</span> <span class="n">current</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">getNext</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">previous</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">getNext</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">previous</span><span class="o">.</span><span class="n">setNext</span><span class="p">(</span><span class="n">current</span><span class="o">.</span><span class="n">getNext</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">current</span><span class="o">.</span><span class="n">getData</span><span class="p">()</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">有序链表
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">class</span> <span class="nc">OrderedList</span><span class="p">(</span><span class="n">UnorderedList</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>  <span class="c1"># O(n)</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">getData</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">item</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">previous</span> <span class="o">=</span> <span class="n">current</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">getNext</span><span class="p">()</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="n">node</span><span class="o">.</span><span class="n">setNext</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">previous</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">previous</span><span class="o">.</span><span class="n">setNext</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>  <span class="c1"># O(n)</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">getData</span><span class="p">()</span> <span class="o">==</span> <span class="n">item</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="n">current</span><span class="o">.</span><span class="n">getData</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">item</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">getNext</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">False</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">递归
</span><span class="s2">1. 递归算法必须具有基本情况
</span><span class="s2">2. 递归算法必须改变状态并靠近其基本情况
</span><span class="s2">3. 递归算法必须递归方式调用自身
</span><span class="s2">&#34;&#34;&#34;</span>

<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">递归算法 整数转字符串
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">toStr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
    <span class="n">digits</span> <span class="o">=</span> <span class="s1">&#39;0123456789ABCDEF&#39;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">base</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">digits</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">toStr</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="n">base</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span> <span class="o">+</span> <span class="n">digits</span><span class="p">[</span><span class="n">n</span> <span class="o">%</span> <span class="n">base</span><span class="p">]</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">河内塔
</span><span class="s2">
</span><span class="s2">1. 把上层的所有盘子移动到中间
</span><span class="s2">2. 把最后一个移动到目标
</span><span class="s2">3. 把中间的所有盘子移动到目标
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">moveTower</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">fromPole</span><span class="p">,</span> <span class="n">toPole</span><span class="p">,</span> <span class="n">withPole</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">height</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">moveTower</span><span class="p">(</span><span class="n">height</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">fromPole</span><span class="p">,</span> <span class="n">withPole</span><span class="p">,</span> <span class="n">toPole</span><span class="p">)</span>
        <span class="n">moveDisk</span><span class="p">(</span><span class="n">fromPole</span><span class="p">,</span> <span class="n">toPole</span><span class="p">)</span>
        <span class="n">moveTower</span><span class="p">(</span><span class="n">height</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">withPole</span><span class="p">,</span> <span class="n">toPole</span><span class="p">,</span> <span class="n">fromPole</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">moveDisk</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span><span class="n">tp</span><span class="p">):</span>
    <span class="k">print</span> <span class="s1">&#39;move disk from &#39;</span> <span class="o">+</span> <span class="n">fp</span> <span class="o">+</span> <span class="s1">&#39; to &#39;</span> <span class="o">+</span> <span class="n">tp</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">探索迷宫
</span><span class="s2">
</span><span class="s2">1. 向北边走一格, 递归
</span><span class="s2">2. 如果向北不能走, 向南走一格, 递归
</span><span class="s2">3. 如果向南不能走, 向东走一格, 递归
</span><span class="s2">4. 如果向东不能走, 向西走一格, 递归
</span><span class="s2">
</span><span class="s2">先走一格, 然后继续向不同方向递归, 直到找到出口
</span><span class="s2">
</span><span class="s2">def searchFrom(maze, startRow, startColumn):
</span><span class="s2">    maze.updatePosition(startRow, startColumn)
</span><span class="s2">    #  Check for base cases:
</span><span class="s2">    #  1. We have run into an obstacle, return false
</span><span class="s2">    if maze[startRow][startColumn] == OBSTACLE : # 碰到墙壁
</span><span class="s2">         return False
</span><span class="s2">    #  2. We have found a square that has already been explored
</span><span class="s2">    if maze[startRow][startColumn] == TRIED: # 已经来过
</span><span class="s2">        return False
</span><span class="s2">    # 3. Success, an outside edge not occupied by an obstacle
</span><span class="s2">    if maze.isExit(startRow,startColumn):
</span><span class="s2">        maze.updatePosition(startRow, startColumn, PART_OF_PATH)
</span><span class="s2">        return True # 判断为出口
</span><span class="s2">    maze.updatePosition(startRow, startColumn, TRIED) # 设置来过
</span><span class="s2">
</span><span class="s2">    # Otherwise, use logical short circuiting to try each
</span><span class="s2">    # direction in turn (if needed)
</span><span class="s2">    found = searchFrom(maze, startRow-1, startColumn) or </span><span class="se">\
</span><span class="se"></span><span class="s2">            searchFrom(maze, startRow+1, startColumn) or </span><span class="se">\
</span><span class="se"></span><span class="s2">            searchFrom(maze, startRow, startColumn-1) or </span><span class="se">\
</span><span class="se"></span><span class="s2">            searchFrom(maze, startRow, startColumn+1)
</span><span class="s2">    if found:
</span><span class="s2">        maze.updatePosition(startRow, startColumn, PART_OF_PATH)
</span><span class="s2">    else:
</span><span class="s2">        maze.updatePosition(startRow, startColumn, DEAD_END)
</span><span class="s2">    return found
</span><span class="s2">&#34;&#34;&#34;</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">动态规划
</span><span class="s2">
</span><span class="s2">硬币找零问题 找到最小可能的硬币数
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">recMC</span><span class="p">(</span><span class="n">coinValueList</span><span class="p">,</span> <span class="n">change</span><span class="p">):</span>
    <span class="n">minCoins</span> <span class="o">=</span> <span class="n">change</span>
    <span class="k">if</span> <span class="n">change</span> <span class="ow">in</span> <span class="n">coinValueList</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coinValueList</span> <span class="k">if</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">change</span><span class="p">]:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">recMC</span><span class="p">(</span><span class="n">coinValueList</span><span class="p">,</span> <span class="n">change</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="n">minCoins</span><span class="p">:</span>
                <span class="n">minCoins</span> <span class="o">=</span> <span class="n">num</span>
    <span class="k">return</span> <span class="n">minCoins</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">以上算法由于计算了大量的重复数据, 所以低效, 可以对已有的数据缓存, 避免重复计算
</span><span class="s2">从顶至下
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">recDC</span><span class="p">(</span><span class="n">coinValueList</span><span class="p">,</span> <span class="n">change</span><span class="p">,</span> <span class="n">knownResults</span><span class="p">):</span>
    <span class="n">minCoins</span> <span class="o">=</span> <span class="n">change</span>
    <span class="k">if</span> <span class="n">change</span> <span class="ow">in</span> <span class="n">coinValueList</span><span class="p">:</span>
        <span class="n">knownResults</span><span class="p">[</span><span class="n">change</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">knownResults</span><span class="p">[</span><span class="n">change</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">knownResults</span><span class="p">[</span><span class="n">change</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coinValueList</span> <span class="k">if</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">change</span><span class="p">]:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">recDC</span><span class="p">(</span><span class="n">coinValueList</span><span class="p">,</span> <span class="n">change</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="n">knownResults</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="n">minCoins</span><span class="p">:</span>
                <span class="n">minCoins</span> <span class="o">=</span> <span class="n">num</span>
        <span class="n">knownResults</span><span class="p">[</span><span class="n">change</span><span class="p">]</span> <span class="o">=</span> <span class="n">minCoins</span>
    <span class="k">return</span> <span class="n">minCoins</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">动态规划
</span><span class="s2">
</span><span class="s2">1. 最小最优解
</span><span class="s2">2. 从小到大, 使用已有的计算结果， 从底至上
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">dpMakeChange</span><span class="p">(</span><span class="n">coinValueList</span><span class="p">,</span> <span class="n">change</span><span class="p">,</span> <span class="n">minCoins</span><span class="p">,</span> <span class="n">coinsUsed</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">cents</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">change</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">coinCount</span> <span class="o">=</span> <span class="n">cents</span>
        <span class="n">newCoin</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coinValueList</span> <span class="k">if</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">cents</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">minCoins</span><span class="p">[</span><span class="n">cents</span><span class="o">-</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">coinCount</span><span class="p">:</span>
                <span class="n">coinCount</span> <span class="o">=</span> <span class="n">minCoins</span><span class="p">[</span><span class="n">cents</span><span class="o">-</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">newCoin</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">minCoins</span><span class="p">[</span><span class="n">cents</span><span class="p">]</span> <span class="o">=</span> <span class="n">coinCount</span>
        <span class="n">coinsUsed</span><span class="p">[</span><span class="n">cents</span><span class="p">]</span> <span class="o">=</span> <span class="n">newCoin</span>
    <span class="k">return</span> <span class="n">minCoins</span><span class="p">[</span><span class="n">change</span><span class="p">]</span>


<span class="c1"># 打印最佳组合的各个值</span>
<span class="k">def</span> <span class="nf">printCoins</span><span class="p">(</span><span class="n">coinsUsed</span><span class="p">,</span> <span class="n">change</span><span class="p">):</span>
    <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">change</span><span class="p">:</span>
        <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coinsUsed</span><span class="p">[</span><span class="n">change</span><span class="p">])</span>
        <span class="n">change</span> <span class="o">-=</span> <span class="n">coinsUsed</span><span class="p">[</span><span class="n">change</span><span class="p">]</span>
    <span class="k">print</span> <span class="n">l</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">背包问题
</span><span class="s2">
</span><span class="s2">n=5是物品的数量，c=10是书包能承受的重量，w=[2,2,6,5,4]是每个物品的重量，v=[6,3,5,4,6]是每个物品的价值
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">bag</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="n">res</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span> <span class="c1"># 把第一列初始化 0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span> <span class="c1"># 行 1~5</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span> <span class="c1"># 列 1~10</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="c1"># 先把上一行的值赋值个当前</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># 如果重量大于物品的行重量且当前价值小于物品价值+前一个物品重量,则重算最大重量</span>
                <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
    <span class="k">print</span> <span class="s1">&#39;最大价值&#39;</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">c</span><span class="p">]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">w</span><span class="p">]</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">c</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">j</span><span class="p">:</span>
            <span class="k">print</span> <span class="s1">&#39;第{}个&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">二分查找
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">binarySearch</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
    <span class="n">first</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">last</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">while</span> <span class="n">first</span> <span class="o">&lt;=</span> <span class="n">last</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="p">(</span><span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">alist</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">item</span><span class="p">:</span>
            <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">alist</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">item</span><span class="p">:</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">found</span>


<span class="c1"># 递归版</span>
<span class="k">def</span> <span class="nf">binarySearch2</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span> <span class="c1"># O( log^n )</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">alist</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">item</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">alist</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">item</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">binarySearch2</span><span class="p">(</span><span class="n">alist</span><span class="p">[:</span><span class="n">mid</span><span class="p">],</span> <span class="n">item</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">binarySearch2</span><span class="p">(</span><span class="n">alist</span><span class="p">[</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="n">item</span><span class="p">)</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">哈希表
</span><span class="s2">
</span><span class="s2">1. 大小为m的哈希表，有从0~m-1为编号的槽 可以用数组表示
</span><span class="s2">2. 项与编号的映射方法叫 hash 函数，简单的示例可以用取余
</span><span class="s2">    ＊ 如果多个项经过 hash 函数得到的编号相同，则称为碰撞
</span><span class="s2">    ＊ 分组求和 把项的多个数字分组求和再取m的余
</span><span class="s2">    ＊ 平方取中 算项的平方值并去中间的某几位 再取m的余
</span><span class="s2">3. 项数/表大小m 的值 称为 负载因子
</span><span class="s2">4. 冲突解决 重新散列
</span><span class="s2">    ＊ 开放寻址 如果槽已被占用，则顺序往槽的下一个槽查找，直到找到空槽(线性探测)
</span><span class="s2">    ＊ 使用链式存储，在同一个编号上存储多个项
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">class</span> <span class="nc">HashTable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">11</span> <span class="c1"># 要为质数</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slots</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span>

    <span class="k">def</span> <span class="nf">_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">key</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>

    <span class="k">def</span> <span class="nf">_rehash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oldhash</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">oldhash</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">hashvalue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">slots</span><span class="p">[</span><span class="n">hashvalue</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="c1"># 新增</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">slots</span><span class="p">[</span><span class="n">hashvalue</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">hashvalue</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">slots</span><span class="p">[</span><span class="n">hashvalue</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span> <span class="c1"># 修改</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">hashvalue</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nextslot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rehash</span><span class="p">(</span><span class="n">hashvalue</span><span class="p">)</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">slots</span><span class="p">[</span><span class="n">nextslot</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">slots</span><span class="p">[</span><span class="n">nextslot</span><span class="p">]</span> <span class="o">!=</span> <span class="n">key</span><span class="p">:</span>
                <span class="n">nextslot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rehash</span><span class="p">(</span><span class="n">hashvalue</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">slots</span><span class="p">[</span><span class="n">nextslot</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">slots</span><span class="p">[</span><span class="n">nextslot</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">nextslot</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_position</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="k">if</span> <span class="n">position</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_get_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span> <span class="c1"># 理想的情况下 O(1) 最差 O(n)</span>
        <span class="n">startslot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">position</span> <span class="o">=</span> <span class="n">startslot</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">slots</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">slots</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">position</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rehash</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">position</span> <span class="o">==</span> <span class="n">startslot</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slots</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">count</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_position</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">position</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">slots</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_position</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">False</span> <span class="k">if</span> <span class="n">position</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="bp">True</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">冒泡排序
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">bubbleSort</span><span class="p">(</span><span class="n">alist</span><span class="p">):</span> <span class="c1"># O(n^2)</span>
    <span class="k">for</span> <span class="n">passnum</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">passnum</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">短冒泡排序
</span><span class="s2">
</span><span class="s2">前一次遍历如果没有发生交换，证明整个序列以排序
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">shortBubbleSort</span><span class="p">(</span><span class="n">alist</span><span class="p">):</span>
    <span class="n">passnum</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">exchange</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">while</span> <span class="n">passnum</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">exchange</span><span class="p">:</span>
        <span class="n">exchange</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">passnum</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">exchange</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">passnum</span> <span class="o">-=</span> <span class="mi">1</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">选择排序
</span><span class="s2">
</span><span class="s2">同冒泡排序，只是减少的交换次数
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">selectionSort</span><span class="p">(</span><span class="n">alist</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">passnum</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">maxPositon</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">passnum</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">alist</span><span class="p">[</span><span class="n">maxPositon</span><span class="p">]:</span>
                <span class="n">maxPositon</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">alist</span><span class="p">[</span><span class="n">passnum</span><span class="p">],</span> <span class="n">alist</span><span class="p">[</span><span class="n">maxPositon</span><span class="p">]</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">maxPositon</span><span class="p">],</span> <span class="n">alist</span><span class="p">[</span><span class="n">passnum</span><span class="p">]</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">插入排序 O(n^2)
</span><span class="s2">
</span><span class="s2">维持最小的已排序序列，迭代未排序项，插入到合适的位置
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">insertionSort</span><span class="p">(</span><span class="n">alist</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)):</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">position</span> <span class="o">=</span> <span class="n">i</span>

        <span class="k">while</span> <span class="n">position</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">alist</span><span class="p">[</span><span class="n">position</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">current</span><span class="p">:</span>
            <span class="n">alist</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">position</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">position</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="n">alist</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="o">=</span> <span class="n">current</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">shell 排序
</span><span class="s2">
</span><span class="s2">通过gap间隔来划分子序列，先对所有的子序列进行插入排序，然后再对整个序列插入排序
</span><span class="s2">O(n^3/2) 稍稍好于插入排序
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">shellSort</span><span class="p">(</span><span class="n">alist</span><span class="p">):</span>
    <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="c1"># 选择gap</span>
    <span class="k">while</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">):</span>
            <span class="n">gapInsertionSort</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>

        <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">//</span> <span class="mi">2</span>


<span class="k">def</span> <span class="nf">gapInsertionSort</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">gap</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="o">+</span><span class="n">gap</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">alist</span><span class="p">),</span> <span class="n">gap</span><span class="p">):</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">position</span> <span class="o">=</span> <span class="n">i</span>

        <span class="k">while</span> <span class="n">position</span> <span class="o">&gt;</span> <span class="n">start</span> <span class="ow">and</span> <span class="n">alist</span><span class="p">[</span><span class="n">position</span><span class="o">-</span><span class="n">gap</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">current</span><span class="p">:</span>
            <span class="n">alist</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">position</span><span class="o">-</span><span class="n">gap</span><span class="p">]</span>
            <span class="n">position</span> <span class="o">-=</span> <span class="n">gap</span>

        <span class="n">alist</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="o">=</span> <span class="n">current</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">归并排序
</span><span class="s2">
</span><span class="s2">递归算法，分治，把序列切割成最小的部分并排序，然后逐步合并已排序的结果 O(nlog^n)
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">mergeSort</span><span class="p">(</span><span class="n">alist</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span> <span class="c1"># 二分 log^n</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[:</span><span class="n">mid</span><span class="p">]</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">mid</span><span class="p">:]</span>

        <span class="n">mergeSort</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="c1"># 递归排序，最小部分为 长度为1的列表</span>
        <span class="n">mergeSort</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

        <span class="c1"># 合并已排序的片段 最大花费n次</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">=</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">alist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">alist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">):</span>
            <span class="n">alist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
            <span class="n">alist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">快速排序 O(nlogn)
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">quickSort</span><span class="p">(</span><span class="n">alist</span><span class="p">):</span>
    <span class="n">quickSortHelper</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">quickSortHelper</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">first</span> <span class="o">&lt;</span> <span class="n">last</span><span class="p">:</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">first</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">alist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">current</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">current</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">alist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">current</span>

        <span class="n">quickSortHelper</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span><span class="n">first</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">quickSortHelper</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">last</span><span class="p">)</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">树
</span><span class="s2">
</span><span class="s2">节点 树的基础部分 可以有附加属性,称为有效载荷 key
</span><span class="s2">边 表示节点之间的联系, 除了 根节点 其它节点都有从父节点来的边(传入边)
</span><span class="s2">根 没有传入边的节点
</span><span class="s2">路径 由边连接的节点的有序序列
</span><span class="s2">子节点 传入边为相同父节点
</span><span class="s2">父节点
</span><span class="s2">兄弟
</span><span class="s2">子树 由父节点 与 子孙节点组成的一组节点与边
</span><span class="s2">叶节点 没有子节点的节点
</span><span class="s2">层数 由根到节点之间边的条数
</span><span class="s2">高度 最大的叶子节点层数
</span><span class="s2">
</span><span class="s2">定义 树由一组节点和连接节点的边组成
</span><span class="s2">
</span><span class="s2">- 树的一个节点指定为根节点
</span><span class="s2">- 除了根,没有节点n通过边与p相连,n是p的子节点
</span><span class="s2">- 从根遍历到某个节点的路径唯一
</span><span class="s2">
</span><span class="s2">定义 树是由根与一系列子树组成,子数的根与根相连,递归定义
</span><span class="s2">&#34;&#34;&#34;</span>

<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">列表表示 二叉树
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">binaryTree</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[]]</span>

<span class="k">def</span> <span class="nf">insertLeft</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">newBranch</span><span class="p">):</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
        <span class="n">root</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">newBranch</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="p">[]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">root</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">newBranch</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[]])</span>
    <span class="k">return</span> <span class="n">root</span>

<span class="k">def</span> <span class="nf">insertRight</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">newBranch</span><span class="p">):</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
        <span class="n">root</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">newBranch</span><span class="p">,</span> <span class="p">[],</span> <span class="n">node</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">root</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">newBranch</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[]])</span>
    <span class="k">return</span> <span class="n">root</span>

<span class="k">def</span> <span class="nf">getRootVal</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">setRootVal</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">newVal</span><span class="p">):</span>
    <span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">newVal</span>

<span class="k">def</span> <span class="nf">getLeftChild</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">getRightChild</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">节点表示
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">class</span> <span class="nc">BinaryTree</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">insertLeft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">node</span>

    <span class="k">def</span> <span class="nf">insertRight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">node</span>

    <span class="k">def</span> <span class="nf">getRootVal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span>

    <span class="k">def</span> <span class="nf">setRootVal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">getLeftChild</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span>

    <span class="k">def</span> <span class="nf">getRightChild</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span>

    <span class="k">def</span> <span class="nf">preorder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">preorder</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">preorder</span><span class="p">()</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">使用树构建数值运算
</span><span class="s2">( 1 + ( 4 * 3 ) )
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">buildParseTree</span><span class="p">(</span><span class="n">fpexp</span><span class="p">):</span>
    <span class="n">fplist</span> <span class="o">=</span> <span class="n">fpexp</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="n">pstack</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">()</span>
    <span class="n">etree</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">pstack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">etree</span><span class="p">)</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">etree</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fplist</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="s1">&#39;(&#39;</span><span class="p">:</span>
            <span class="n">current</span><span class="o">.</span><span class="n">insertLeft</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">pstack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">getLeftChild</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;)&#39;</span><span class="p">]:</span>
            <span class="n">current</span><span class="o">.</span><span class="n">setRootVal</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">pstack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">]:</span>
            <span class="n">current</span><span class="o">.</span><span class="n">setRootVal</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">current</span><span class="o">.</span><span class="n">insertRight</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">pstack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">getRightChild</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="s1">&#39;)&#39;</span><span class="p">:</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">pstack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">print</span> <span class="n">current</span><span class="o">.</span><span class="n">getRootVal</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">etree</span>


<span class="kn">import</span> <span class="nn">operator</span>

<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">递归算式树求值
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">parseTree</span><span class="p">):</span>
    <span class="n">opers</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;+&#39;</span><span class="p">:</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span><span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">:</span><span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">}</span>

    <span class="n">left</span> <span class="o">=</span> <span class="n">parseTree</span><span class="o">.</span><span class="n">getLeftChild</span><span class="p">()</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">parseTree</span><span class="o">.</span><span class="n">getRightChild</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">left</span> <span class="ow">and</span> <span class="n">right</span><span class="p">:</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">opers</span><span class="p">[</span><span class="n">parseTree</span><span class="o">.</span><span class="n">getRootVal</span><span class="p">()]</span>
        <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="n">evaluate</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">right</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">parseTree</span><span class="o">.</span><span class="n">getRootVal</span><span class="p">()</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">树的遍历
</span><span class="s2">
</span><span class="s2">前序 返问根,递归前序遍历左子树,递归前序遍历右子树
</span><span class="s2">中序 递归中序遍历左子树,返问根,递归中序遍历右子树
</span><span class="s2">后序 递归后序遍历左子树,递归后序遍历右子树,返问根
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">preorder</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span> <span class="c1"># 前序</span>
    <span class="k">if</span> <span class="n">tree</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">tree</span><span class="o">.</span><span class="n">getRootVal</span><span class="p">()</span>
        <span class="n">preorder</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getLeftChild</span><span class="p">())</span>
        <span class="n">preorder</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getRightChild</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">postorder</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span> <span class="c1"># 后序</span>
    <span class="k">if</span> <span class="n">tree</span><span class="p">:</span>
        <span class="n">postorder</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getLeftChild</span><span class="p">())</span>
        <span class="n">postorder</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getRightChild</span><span class="p">())</span>
        <span class="k">print</span> <span class="n">tree</span><span class="o">.</span><span class="n">getRootVal</span><span class="p">()</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">遍历求值
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">postordereval</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
    <span class="n">opers</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;+&#39;</span><span class="p">:</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span><span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">:</span><span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">}</span>
    <span class="n">res1</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">res2</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">tree</span><span class="p">:</span>
        <span class="n">res1</span> <span class="o">=</span> <span class="n">postordereval</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getLeftChild</span><span class="p">())</span>
        <span class="n">res2</span> <span class="o">=</span> <span class="n">postordereval</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getRightChild</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">res1</span> <span class="ow">and</span> <span class="n">res2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">opers</span><span class="p">[</span><span class="n">tree</span><span class="o">.</span><span class="n">getRootVal</span><span class="p">()](</span><span class="n">res1</span><span class="p">,</span> <span class="n">res2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tree</span><span class="o">.</span><span class="n">getRootVal</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">inorder</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span> <span class="c1"># 中序</span>
    <span class="k">if</span> <span class="n">tree</span><span class="p">:</span>
        <span class="n">inorder</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getLeftChild</span><span class="p">())</span>
        <span class="k">print</span> <span class="n">tree</span><span class="o">.</span><span class="n">getRootVal</span><span class="p">()</span>
        <span class="n">inorder</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getRightChild</span><span class="p">())</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">打印原始分析树
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">printexp</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">if</span> <span class="n">tree</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="n">printexp</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getLeftChild</span><span class="p">())</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">tree</span><span class="o">.</span><span class="n">getRootVal</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">printexp</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getRightChild</span><span class="p">())</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span>
    <span class="k">return</span> <span class="n">s</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">二叉堆 最小堆
</span><span class="s2">
</span><span class="s2">子节点的一定小于父节点，根节点最小
</span><span class="s2">每层的最大节点个数为2^h，所以子节点一定是父节点的2n 2n＋1
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">class</span> <span class="nc">BinHeap</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span> <span class="c1"># O(log2^n)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">//</span> <span class="mi">2</span> <span class="c1"># 找到父节点的位置</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># 对比交换</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">delMin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># O(log2^n)</span>
        <span class="n">minVal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># 删除最小,把最大的移动到根</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_percDown</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># 遍历比较，把合适的移动到根</span>
        <span class="k">return</span> <span class="n">minVal</span>

    <span class="k">def</span> <span class="nf">_minChild</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">_percDown</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span><span class="p">:</span>
            <span class="n">mc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minChild</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">mc</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">mc</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">mc</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">mc</span>

    <span class="k">def</span> <span class="nf">buildHeap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alist</span><span class="p">):</span> <span class="c1"># O(n)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">alist</span><span class="p">[:]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_percDown</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">最大堆
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">class</span> <span class="nc">MaxBinHeap</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">delMax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">maxVal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_percUp</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">maxVal</span>

    <span class="k">def</span> <span class="nf">_maxChild</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">_percUp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span><span class="p">:</span>
            <span class="n">mc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxChild</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">mc</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">mc</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">mc</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">mc</span>

    <span class="k">def</span> <span class="nf">buildHeap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alist</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">heapList</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">alist</span><span class="p">[:]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_percUp</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">堆排序
</span><span class="s2">
</span><span class="s2">构建最大堆
</span><span class="s2">把根交换到最后
</span><span class="s2">递归n－1构建最大堆，交换 O(nlogn)
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">heap_sort</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">sift_down</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">start</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">child</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">root</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">child</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">child</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="ow">and</span> <span class="n">lst</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lst</span><span class="p">[</span><span class="n">child</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">child</span> <span class="o">=</span> <span class="n">child</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">lst</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lst</span><span class="p">[</span><span class="n">child</span><span class="p">]:</span>
                <span class="n">lst</span><span class="p">[</span><span class="n">root</span><span class="p">],</span> <span class="n">lst</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">child</span><span class="p">],</span> <span class="n">lst</span><span class="p">[</span><span class="n">root</span><span class="p">]</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">child</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="c1"># 构建最大堆</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sift_down</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lst</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">end</span><span class="p">],</span> <span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># 交换，重复构建</span>
        <span class="n">sift_down</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">二叉搜索树
</span><span class="s2">
</span><span class="s2">节点的左子节点必须小于节点的key
</span><span class="s2">节点的右子节点必须大于节点的key
</span><span class="s2">
</span><span class="s2">get put delete 都是遍历高度 O(log2^n)
</span><span class="s2">如果输入是有序的,那么就是最坏的结果O(n), 因为只会遍历左边或者右边
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">class</span> <span class="nc">BinarySearchTree</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span> <span class="c1"># 复杂度在于树的高度 O(log2^n)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">current</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="n">current</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">hasRightChild</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">current</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">current</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">hasLeftChild</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">current</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">current</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">current</span><span class="o">.</span><span class="n">playload</span> <span class="o">=</span> <span class="n">val</span> <span class="c1"># key 相同时 直接替换值</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span> <span class="c1"># O(log2^n)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">playload</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">current</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">current</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="n">current</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">current</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">current</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">current</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span> <span class="c1"># 虽然很复杂, 但是实际上向下遍历找到合适的节点, 所有最大还是高度 O(log2^n)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">removeNode</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">removeNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">isLeaf</span><span class="p">():</span> <span class="c1"># 如果是叶子节点,直接删除</span>
            <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">isLeftChild</span><span class="p">():</span>
                <span class="n">current</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">elif</span> <span class="n">current</span><span class="o">.</span><span class="n">hasBothChildren</span><span class="p">():</span> <span class="c1"># 有2个子节点</span>
            <span class="n">succ</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">findSuccessor</span><span class="p">()</span>
            <span class="n">succ</span><span class="o">.</span><span class="n">spliceOut</span><span class="p">()</span>
            <span class="n">current</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">succ</span><span class="o">.</span><span class="n">key</span>
            <span class="n">current</span><span class="o">.</span><span class="n">playload</span> <span class="o">=</span> <span class="n">succ</span><span class="o">.</span><span class="n">key</span>

        <span class="k">else</span><span class="p">:</span> <span class="c1"># 有1个子节点</span>
            <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">hasLeftChild</span><span class="p">():</span> <span class="c1"># 有左节点</span>
                <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">isLeftChild</span><span class="p">():</span>
                    <span class="n">current</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">left</span>
                    <span class="n">current</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">parent</span>
                <span class="k">elif</span> <span class="n">current</span><span class="o">.</span><span class="n">isRightChild</span><span class="p">():</span>
                    <span class="n">current</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">left</span>
                    <span class="n">current</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">parent</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># 根节点,直接使用子节点的数据替换自己</span>
                    <span class="n">current</span><span class="o">.</span><span class="n">replaceNodeData</span><span class="p">(</span><span class="n">current</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">current</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">playload</span><span class="p">,</span>
                        <span class="n">current</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">current</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">isLeftChild</span><span class="p">():</span>
                    <span class="n">current</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">right</span>
                    <span class="n">current</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">parent</span>
                <span class="k">elif</span> <span class="n">current</span><span class="o">.</span><span class="n">isRightChild</span><span class="p">():</span>
                    <span class="n">current</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">right</span>
                    <span class="n">current</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">parent</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># 根节点</span>
                    <span class="n">current</span><span class="o">.</span><span class="n">replaceNodeData</span><span class="p">(</span><span class="n">current</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">current</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">playload</span><span class="p">,</span>
                        <span class="n">current</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">current</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">playload</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">balanceFactor</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">hasLeftChild</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span>

    <span class="k">def</span> <span class="nf">hasRightChild</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span>

    <span class="k">def</span> <span class="nf">isLeftChild</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">hasLeftChild</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">isRightChild</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">hasRightChild</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">isRoot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>

    <span class="k">def</span> <span class="nf">isLeaf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hasAnyChildren</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span>

    <span class="k">def</span> <span class="nf">hasBothChildren</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span>

    <span class="k">def</span> <span class="nf">replaceNodeData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">lc</span><span class="p">,</span> <span class="n">rc</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">playload</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">lc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">rc</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasLeftChild</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasRightChild</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">findSuccessor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">succ</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasRightChild</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">findMin</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isLeftChild</span><span class="p">():</span>
                    <span class="n">succ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># 如果没有右节点, 且自己是右节点, 父节点小于自己, 遍历向上找</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># 可以肯定的是节点 右边节点一定会大于节点本身</span>
                    <span class="n">succ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">findSuccessor</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">succ</span>

    <span class="k">def</span> <span class="nf">findMin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">current</span><span class="o">.</span><span class="n">hasLeftChild</span><span class="p">():</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">left</span>
        <span class="k">return</span> <span class="n">current</span>

    <span class="k">def</span> <span class="nf">spliceOut</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isLeaf</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isLeftChild</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasLeftChild</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isLeftChild</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isLeftChild</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasLeftChild</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">ele</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasRightChild</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">ele</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">平衡二叉树
</span><span class="s2">AVL树 自动保持平衡的树
</span><span class="s2">
</span><span class="s2">平衡 根的左子树与右子树的高度差不超过1
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">class</span> <span class="nc">AvlTree</span><span class="p">(</span><span class="n">BinarySearchTree</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">current</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="n">current</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">hasRightChild</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">current</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">current</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">updateBalance</span><span class="p">(</span><span class="n">current</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">hasLeftChild</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">current</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">current</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">updateBalance</span><span class="p">(</span><span class="n">current</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">current</span><span class="o">.</span><span class="n">playload</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">updateBalance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">        1. 递归调用到树的根，直到找到平衡因子大于1的节点
</span><span class="s2">        2. 父节点的平衡因子已调整为零。你应该说服自己，一旦一个子树的平衡因子为零，那么它的祖先节点的平衡不会改变。
</span><span class="s2">        &#34;&#34;&#34;</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">balanceFactor</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">balanceFactor</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rebalance</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="c1"># 通过旋转可以保证节点平衡因子为0</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">parent</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">isLeftChild</span><span class="p">():</span>
                <span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">balanceFactor</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">isRightChild</span><span class="p">():</span>
                <span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">balanceFactor</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">balanceFactor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">updateBalance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rebalance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">balanceFactor</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">balanceFactor</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rotateRight</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotateLeft</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">balanceFactor</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">balanceFactor</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rotateLeft</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotateRight</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rotateLeft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rotRoot</span><span class="p">):</span> <span class="c1"># 左旋转</span>
        <span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">        1. 提升右孩子（B）成为子树的根。
</span><span class="s2">        2. 将旧根（A）移动为新根的左子节点。
</span><span class="s2">        3. 如果新根（B）已经有一个左孩子，那么使它成为新左孩子（A）的右孩子。
</span><span class="s2">           注意：由于新根（B）是A的右孩子，A 的右孩子在这一点上保证为空。
</span><span class="s2">           这允许我们添加一个新的节点作为右孩子，不需进一步的考虑。
</span><span class="s2">        &#34;&#34;&#34;</span>
        <span class="n">newRoot</span> <span class="o">=</span> <span class="n">rotRoot</span><span class="o">.</span><span class="n">right</span> <span class="c1"># 右节点为新根</span>
        <span class="n">rotRoot</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">newRoot</span><span class="o">.</span><span class="n">left</span> <span class="c1"># 新根的左节点称为旧根的右节点</span>
        <span class="k">if</span> <span class="n">newRoot</span><span class="o">.</span><span class="n">hasLeftChild</span><span class="p">():</span>
            <span class="n">newRoot</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">rotRoot</span>
        <span class="n">newRoot</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">rotRoot</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">if</span> <span class="n">rotRoot</span><span class="o">.</span><span class="n">isRoot</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">newRoot</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rotRoot</span><span class="o">.</span><span class="n">isLeftChild</span><span class="p">():</span>
                <span class="n">rotRoot</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">newRoot</span>
            <span class="k">elif</span> <span class="n">rotRoot</span><span class="o">.</span><span class="n">isRightChild</span><span class="p">():</span>
                <span class="n">rotRoot</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">newRoot</span>
        <span class="n">newRoot</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">rotRoot</span>
        <span class="n">rotRoot</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">newRoot</span>
        <span class="n">rotRoot</span><span class="o">.</span><span class="n">balanceFactor</span> <span class="o">=</span> <span class="n">rotRoot</span><span class="o">.</span><span class="n">balanceFactor</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">newRoot</span><span class="o">.</span><span class="n">balanceFactor</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">newRoot</span><span class="o">.</span><span class="n">balanceFactor</span> <span class="o">=</span> <span class="n">newRoot</span><span class="o">.</span><span class="n">balanceFactor</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">rotRoot</span><span class="o">.</span><span class="n">balanceFactor</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rotateRight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rotRoot</span><span class="p">):</span> <span class="c1"># 右旋转</span>
        <span class="n">newRoot</span> <span class="o">=</span> <span class="n">rotRoot</span><span class="o">.</span><span class="n">left</span>
        <span class="n">rotRoot</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">newRoot</span><span class="o">.</span><span class="n">right</span>
        <span class="k">if</span> <span class="n">newRoot</span><span class="o">.</span><span class="n">hasRightChild</span><span class="p">():</span>
            <span class="n">newRoot</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">rotRoot</span>
        <span class="n">newRoot</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">rotRoot</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">if</span> <span class="n">rotRoot</span><span class="o">.</span><span class="n">isRoot</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">newRoot</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rotRoot</span><span class="o">.</span><span class="n">isLeftChild</span><span class="p">():</span>
                <span class="n">rotRoot</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">newRoot</span>
            <span class="k">elif</span> <span class="n">rotRoot</span><span class="o">.</span><span class="n">isRightChild</span><span class="p">():</span>
                <span class="n">rotRoot</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">newRoot</span>
        <span class="n">newRoot</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">rotRoot</span>
        <span class="n">rotRoot</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">newRoot</span>
        <span class="n">rotRoot</span><span class="o">.</span><span class="n">balanceFactor</span> <span class="o">=</span> <span class="n">rotRoot</span><span class="o">.</span><span class="n">balanceFactor</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">newRoot</span><span class="o">.</span><span class="n">balanceFactor</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">newRoot</span><span class="o">.</span><span class="n">balanceFactor</span> <span class="o">=</span> <span class="n">newRoot</span><span class="o">.</span><span class="n">balanceFactor</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">rotRoot</span><span class="o">.</span><span class="n">balanceFactor</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">图
</span><span class="s2">
</span><span class="s2">顶点 同树中的节点
</span><span class="s2">边 连接2个顶点,可以是多个方向的,如果图中边都只有一个方法,则称为有向图
</span><span class="s2">权重 边可以被加权,表示顶点到顶点过去的成本
</span><span class="s2">路径 由边连接的顶点的序列, 未加权的路径长度n-1, 加权的为路径所有边权重的和
</span><span class="s2">循环 有向图的循环是同一顶点为起点和终点的路径, 没有循环的图称为非循环图形, 没有循环的有向图称为无环图 DAG
</span><span class="s2">
</span><span class="s2">图 是由顶点集合与边集合组成的 G = (V, E) G 图 V 顶点集合 E 边的集合
</span><span class="s2">&#34;&#34;&#34;</span>

<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">邻接矩阵
</span><span class="s2">
</span><span class="s2">行与列存储了图的顶点,行与列的单元格存了边的加权值,如果2个顶点间的单元格值,则2个顶点相邻
</span><span class="s2">由于存在很多的空单元格,大部分情况下矩阵是稀疏的,但是对于边很多的情况下,领接矩阵很适合
</span><span class="s2">
</span><span class="s2">领接表
</span><span class="s2">
</span><span class="s2">适用于边很稀疏的情况
</span><span class="s2">对应于列的顶点列表,对每个顶点维护一个边的列表,保存了顶点与权重
</span><span class="s2">空间更高效,并且保存了顶点直接连接的其它顶点
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">class</span> <span class="nc">Vertex</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">num</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="nb">id</span> <span class="o">=</span> <span class="n">num</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectedTo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;white&#39;</span> <span class="c1"># 是否已访问 white 未访问 gray 正在访问 black 已访问</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pred</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># 上级顶点</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disc</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># 距离开始顶点的距离或者顶点标识为 gray 的时间</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fin</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># 顶点标识为 black 的时间</span>

    <span class="k">def</span> <span class="nf">addNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nbr</span><span class="p">,</span><span class="n">weight</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectedTo</span><span class="p">[</span><span class="n">nbr</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span>

    <span class="k">def</span> <span class="nf">setColor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">color</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">color</span>

    <span class="k">def</span> <span class="nf">setDistance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">d</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">setPred</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">p</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pred</span> <span class="o">=</span> <span class="n">p</span>

    <span class="k">def</span> <span class="nf">setDiscovery</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dtime</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disc</span> <span class="o">=</span> <span class="n">dtime</span>

    <span class="k">def</span> <span class="nf">setFinish</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ftime</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fin</span> <span class="o">=</span> <span class="n">ftime</span>

    <span class="k">def</span> <span class="nf">getFinish</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fin</span>

    <span class="k">def</span> <span class="nf">getDiscovery</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">disc</span>

    <span class="k">def</span> <span class="nf">getPred</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pred</span>

    <span class="k">def</span> <span class="nf">getDistance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span>

    <span class="k">def</span> <span class="nf">getColor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span>

    <span class="k">def</span> <span class="nf">getConnections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectedTo</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">getWeight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nbr</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectedTo</span><span class="p">[</span><span class="n">nbr</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">getId</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="nb">id</span>


<span class="k">class</span> <span class="nc">Graph</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertList</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numVertices</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">addVertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">ver</span> <span class="o">=</span> <span class="n">Vertex</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numVertices</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertList</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ver</span>
        <span class="k">return</span> <span class="n">ver</span>

    <span class="k">def</span> <span class="nf">getVertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertList</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertList</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertList</span>

    <span class="k">def</span> <span class="nf">addEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">cost</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">f</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertList</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addVertex</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertList</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addVertex</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertList</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">addNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertList</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">cost</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getVertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertList</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertList</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">构建字梯图
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">buildGraph</span><span class="p">(</span><span class="n">words</span><span class="p">):</span> <span class="c1"># O(n^2)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)):</span>
            <span class="n">bucket</span> <span class="o">=</span> <span class="n">word</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">if</span> <span class="n">bucket</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">bucket</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">bucket</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">word</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">bucket</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">word1</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">bucket</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">word2</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">bucket</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">word1</span> <span class="o">!=</span> <span class="n">word2</span><span class="p">:</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="n">word1</span><span class="p">,</span> <span class="n">word2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">广度优先 BFS
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">start</span><span class="p">):</span> <span class="c1"># O(V) 每个顶点只会访问一次</span>
    <span class="n">start</span><span class="o">.</span><span class="n">setDistance</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">start</span><span class="o">.</span><span class="n">setPred</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
    <span class="n">vertQueue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
    <span class="n">vertQueue</span><span class="o">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">vertQueue</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">currentVert</span> <span class="o">=</span> <span class="n">vertQueue</span><span class="o">.</span><span class="n">dequeue</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">nbr</span> <span class="ow">in</span> <span class="n">currentVert</span><span class="o">.</span><span class="n">getConnections</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nbr</span><span class="o">.</span><span class="n">getColor</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;white&#39;</span><span class="p">):</span>
                <span class="n">nbr</span><span class="o">.</span><span class="n">setColor</span><span class="p">(</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
                <span class="n">nbr</span><span class="o">.</span><span class="n">setDistance</span><span class="p">(</span><span class="n">currentVert</span><span class="o">.</span><span class="n">getDistance</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">nbr</span><span class="o">.</span><span class="n">setPred</span><span class="p">(</span><span class="n">currentVert</span><span class="p">)</span>
                <span class="n">vertQueue</span><span class="o">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">nbr</span><span class="p">)</span>
            <span class="n">currentVert</span><span class="o">.</span><span class="n">setColor</span><span class="p">(</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">y</span><span class="p">):</span> <span class="c1"># 反向追踪找到路径</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">y</span>
    <span class="k">while</span> <span class="n">x</span><span class="o">.</span><span class="n">getPred</span><span class="p">():</span>
        <span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">getId</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">getPred</span><span class="p">()</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">骑士之旅
</span><span class="s2">
</span><span class="s2">棋盘上的每个单元格都需要访问到
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">knightGraph</span><span class="p">(</span><span class="n">bdSize</span><span class="p">):</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bdSize</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bdSize</span><span class="p">):</span>
            <span class="n">nodeId</span> <span class="o">=</span> <span class="n">posToNodeId</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">bdSize</span><span class="p">)</span>
            <span class="n">newPositions</span> <span class="o">=</span> <span class="n">genLegalMoves</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">bdSize</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">newPositions</span><span class="p">:</span>
                <span class="n">nid</span> <span class="o">=</span> <span class="n">posToNodeId</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bdSize</span><span class="p">)</span>
                <span class="n">graph</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="n">nodeId</span><span class="p">,</span> <span class="n">nid</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">graph</span>


<span class="k">def</span> <span class="nf">posToNodeId</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">board_size</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">row</span> <span class="o">*</span> <span class="n">board_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">column</span>


<span class="k">def</span> <span class="nf">genLegalMoves</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bdSize</span><span class="p">):</span>
    <span class="n">newMoves</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">moveOffsets</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
                   <span class="p">(</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),(</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span> <span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),(</span> <span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">moveOffsets</span><span class="p">:</span>
        <span class="n">newX</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">newY</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">legalCoord</span><span class="p">(</span><span class="n">newX</span><span class="p">,</span> <span class="n">bdSize</span><span class="p">)</span> <span class="ow">and</span> \
            <span class="n">legalCoord</span><span class="p">(</span><span class="n">newY</span><span class="p">,</span> <span class="n">bdSize</span><span class="p">):</span>

            <span class="n">newMoves</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">newX</span><span class="p">,</span> <span class="n">newY</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">newMoves</span>


<span class="k">def</span> <span class="nf">legalCoord</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bdSize</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">bdSize</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">深度优先 DFS
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">knightTour</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
    <span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">    n: 搜索树中当前深度
</span><span class="s2">    path: 搜索路径节点列表
</span><span class="s2">    u: 希望找到的顶点
</span><span class="s2">    limit: 路径中的节点数，最大的深度
</span><span class="s2">    &#34;&#34;&#34;</span>
    <span class="n">u</span><span class="o">.</span><span class="n">setColor</span><span class="p">(</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
    <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">:</span>
        <span class="c1"># nbrList = list(u.getConnections())</span>
        <span class="n">nbrList</span> <span class="o">=</span> <span class="n">orderByAvail</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">done</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nbrList</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nbrList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">getColor</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;white&#39;</span><span class="p">:</span>
                <span class="n">done</span> <span class="o">=</span> <span class="n">knightTour</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">nbrList</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">limit</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>  <span class="c1"># prepare to backtrack</span>
            <span class="n">path</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">u</span><span class="o">.</span><span class="n">setColor</span><span class="p">(</span><span class="s1">&#39;white&#39;</span><span class="p">)</span> <span class="c1"># 回溯，遍历下一个邻居</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">done</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="n">done</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">启发式
</span><span class="s2">
</span><span class="s2">倾向与先遍历到有较少的可选的节点，这样骑士会先覆盖棋盘周边的方格，然后向中间，
</span><span class="s2">避免在中间路径过多的选择, 由中间向周边发散会产生更多的短路径
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">orderByAvail</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">resList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">getConnections</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">getColor</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;white&#39;</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">getConnections</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">w</span><span class="o">.</span><span class="n">getColor</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;white&#39;</span><span class="p">:</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">resList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">c</span><span class="p">,</span><span class="n">v</span><span class="p">))</span>
    <span class="n">resList</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">resList</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">DFSGraph</span><span class="p">(</span><span class="n">Graph</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DFSGraph</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">aVertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">aVertex</span><span class="o">.</span><span class="n">setColor</span><span class="p">(</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>
            <span class="n">aVertex</span><span class="o">.</span><span class="n">setPred</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">aVertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">aVertex</span><span class="o">.</span><span class="n">getColor</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;white&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfsvisit</span><span class="p">(</span><span class="n">aVertex</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dfsvisit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">startVertex</span><span class="p">):</span> <span class="c1"># O(V + E) 覆盖每个顶点，并且每个边都会过一次</span>
        <span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">        遍历过后的所有其它节点都能找到到开始节点的路径，构成深度优先森林
</span><span class="s2">        &#34;&#34;&#34;</span>
        <span class="n">startVertex</span><span class="o">.</span><span class="n">setColor</span><span class="p">(</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">startVertex</span><span class="o">.</span><span class="n">setDiscovery</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="c1"># 开始遍历的时间</span>
        <span class="k">for</span> <span class="n">nextVertex</span> <span class="ow">in</span> <span class="n">startVertex</span><span class="o">.</span><span class="n">getConnections</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">nextVertex</span><span class="o">.</span><span class="n">getColor</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;white&#39;</span><span class="p">:</span>
                <span class="n">nextVertex</span><span class="o">.</span><span class="n">setPred</span><span class="p">(</span><span class="n">startVertex</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfsvisit</span><span class="p">(</span><span class="n">nextVertex</span><span class="p">)</span>
        <span class="n">startVertex</span><span class="o">.</span><span class="n">setColor</span><span class="p">(</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">startVertex</span><span class="o">.</span><span class="n">setFinish</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="c1"># 遍历完成的时间</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">拓扑排序
</span><span class="s2">
</span><span class="s2">有向无环图
</span><span class="s2">1. 对于某些图 g 调用 dfs(g)。我们想要调用深度优先搜索的主要原因是计算每个顶点的完成时间。
</span><span class="s2">2. 以完成时间的递减顺序将顶点存储在列表中。
</span><span class="s2">3. 返回有序列表作为拓扑排序的结果。得到正确的完成步骤
</span><span class="s2">&#34;&#34;&#34;</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">强联通分量
</span><span class="s2">
</span><span class="s2">C 是 G 的子集, 并且 C 的每个顶点都是互通的(强联通)
</span><span class="s2">1. 调用dfs计算G的每个顶点的完成时间
</span><span class="s2">2. 计算G^T 复制G,并翻转每个边的方向
</span><span class="s2">3. 为G^T调用dfs, 但在 DFS 的主循环中，以完成时间的递减顺序探查每个顶点。
</span><span class="s2">4. 在步骤 3 中计算的森林中的每个树是强连通分量。输出森林中每个树中每个顶点的顶点标识组件。
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">buildSCC</span><span class="p">():</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">DFSGraph</span><span class="p">()</span>
    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">dfs</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">g</span>


<span class="k">def</span> <span class="nf">buildGT</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="n">newG</span> <span class="o">=</span> <span class="n">DFSGraph</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">vert</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span> <span class="c1"># 构建G^T</span>
        <span class="k">for</span> <span class="n">nbr</span> <span class="ow">in</span> <span class="n">vert</span><span class="o">.</span><span class="n">connectedTo</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">newG</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="n">nbr</span><span class="o">.</span><span class="n">getId</span><span class="p">(),</span> <span class="n">vert</span><span class="o">.</span><span class="n">getId</span><span class="p">())</span>
    <span class="n">verts</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">newG</span><span class="o">.</span><span class="n">vertList</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">vert</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">getVertex</span><span class="p">(</span><span class="n">vert</span><span class="o">.</span><span class="n">getId</span><span class="p">())</span><span class="o">.</span><span class="n">getFinish</span><span class="p">(),</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">aVertex</span> <span class="ow">in</span> <span class="n">verts</span><span class="p">:</span>
        <span class="n">aVertex</span><span class="o">.</span><span class="n">setColor</span><span class="p">(</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>
        <span class="n">aVertex</span><span class="o">.</span><span class="n">setPred</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">aVertex</span> <span class="ow">in</span> <span class="n">verts</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">aVertex</span><span class="o">.</span><span class="n">getColor</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;white&#39;</span><span class="p">:</span>
            <span class="n">newG</span><span class="o">.</span><span class="n">dfsvisit</span><span class="p">(</span><span class="n">aVertex</span><span class="p">)</span> <span class="c1"># 构建的子树即为强连通分量</span>
    <span class="k">return</span> <span class="n">newG</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">最短路径问题
</span><span class="s2">
</span><span class="s2">针对加权边的图
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">class</span> <span class="nc">PriorityQueue</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">    优先级队列
</span><span class="s2">    &#34;&#34;&#34;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">heapArray</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">buildHeap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">alist</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">heapArray</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">alist</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">heapArray</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">percDown</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">percDown</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span><span class="p">:</span>
            <span class="n">mc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minChild</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapArray</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapArray</span><span class="p">[</span><span class="n">mc</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">heapArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapArray</span><span class="p">[</span><span class="n">mc</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">heapArray</span><span class="p">[</span><span class="n">mc</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">mc</span>

    <span class="k">def</span> <span class="nf">minChild</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">*</span><span class="mi">2</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">i</span><span class="o">*</span><span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapArray</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapArray</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="n">i</span><span class="o">*</span><span class="mi">2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">percUp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapArray</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapArray</span><span class="p">[</span><span class="n">i</span><span class="o">//</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
               <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapArray</span><span class="p">[</span><span class="n">i</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">heapArray</span><span class="p">[</span><span class="n">i</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">heapArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">//</span><span class="mi">2</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">k</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">heapArray</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">percUp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">delMin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapArray</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">heapArray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapArray</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">heapArray</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">percDown</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">retval</span>

    <span class="k">def</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">decreaseKey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span><span class="p">,</span><span class="n">amt</span><span class="p">):</span>
        <span class="c1"># this is a little wierd, but we need to find the heap thing to decrease by</span>
        <span class="c1"># looking at its value</span>
        <span class="n">done</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">myKey</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">done</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentSize</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapArray</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">:</span>
                <span class="n">done</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">myKey</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">myKey</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">heapArray</span><span class="p">[</span><span class="n">myKey</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">amt</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">heapArray</span><span class="p">[</span><span class="n">myKey</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">percUp</span><span class="p">(</span><span class="n">myKey</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">vtx</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">heapArray</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">vtx</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">dijkstra算法, 类似于bfs, 只是使用优先级队列, 按权重最小排列
</span><span class="s2">最终算出其它顶点与开始顶点间最短距离
</span><span class="s2">只有权重为正才能正常运行,否则会死循环
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">dijkstra</span><span class="p">(</span><span class="n">aGraph</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span> <span class="c1"># O((V + E)log^V )</span>
    <span class="n">pq</span> <span class="o">=</span> <span class="n">PriorityQueue</span><span class="p">()</span>
    <span class="n">start</span><span class="o">.</span><span class="n">setDistance</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">pq</span><span class="o">.</span><span class="n">buildHeap</span><span class="p">([(</span><span class="n">v</span><span class="o">.</span><span class="n">getDistance</span><span class="p">(),</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">aGraph</span><span class="p">])</span> <span class="c1"># 所有的都放进去了</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">pq</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">():</span>
        <span class="n">currentVert</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">delMin</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">nextVert</span> <span class="ow">in</span> <span class="n">currentVert</span><span class="o">.</span><span class="n">getConnections</span><span class="p">():</span>
            <span class="n">newDist</span> <span class="o">=</span> <span class="n">currentVert</span><span class="o">.</span><span class="n">getDistance</span><span class="p">()</span> \
                    <span class="o">+</span> <span class="n">currentVert</span><span class="o">.</span><span class="n">getWeight</span><span class="p">(</span><span class="n">nextVert</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">newDist</span> <span class="o">&lt;</span> <span class="n">nextVert</span><span class="o">.</span><span class="n">getDistance</span><span class="p">():</span>
                <span class="n">nextVert</span><span class="o">.</span><span class="n">setDistance</span><span class="p">(</span><span class="n">newDist</span><span class="p">)</span>
                <span class="n">nextVert</span><span class="o">.</span><span class="n">setPred</span><span class="p">(</span><span class="n">currentVert</span><span class="p">)</span>
                <span class="n">pq</span><span class="o">.</span><span class="n">decreaseKey</span><span class="p">(</span><span class="n">nextVert</span><span class="p">,</span> <span class="n">newDist</span><span class="p">)</span> <span class="c1"># 移动到队列的前面</span>


<span class="sa">u</span><span class="s2">&#34;&#34;&#34;
</span><span class="s2">最小权重生成树
</span><span class="s2">
</span><span class="s2">Prim生成树算法
</span><span class="s2">
</span><span class="s2">使用最小权重的边重写顶点的路径, 贪婪算法
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">def</span> <span class="nf">prim</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
    <span class="n">pq</span> <span class="o">=</span> <span class="n">PriorityQueue</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
        <span class="n">v</span><span class="o">.</span><span class="n">setDistance</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">maxint</span><span class="p">)</span>
        <span class="n">v</span><span class="o">.</span><span class="n">setPred</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
    <span class="n">start</span><span class="o">.</span><span class="n">setDistance</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">pq</span><span class="o">.</span><span class="n">buildHeap</span><span class="p">([(</span><span class="n">v</span><span class="o">.</span><span class="n">getDistance</span><span class="p">(),</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">])</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">pq</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">():</span>
        <span class="n">currentVert</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">delMin</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">nextVert</span> <span class="ow">in</span> <span class="n">currentVert</span><span class="o">.</span><span class="n">getConnections</span><span class="p">():</span>
            <span class="n">newCost</span> <span class="o">=</span> <span class="n">currentVert</span><span class="o">.</span><span class="n">getWeight</span><span class="p">(</span><span class="n">nextVert</span><span class="p">)</span> <span class="o">+</span> <span class="n">currentVert</span><span class="o">.</span><span class="n">getDistance</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">nextVert</span> <span class="ow">in</span> <span class="n">pq</span> <span class="ow">and</span> <span class="n">newCost</span> <span class="o">&lt;</span> <span class="n">nextVert</span><span class="o">.</span><span class="n">getDistance</span><span class="p">():</span>
                <span class="n">nextVert</span><span class="o">.</span><span class="n">setPred</span><span class="p">(</span><span class="n">currentVert</span><span class="p">)</span>
                <span class="n">nextVert</span><span class="o">.</span><span class="n">setDistance</span><span class="p">(</span><span class="n">newCost</span><span class="p">)</span>
                <span class="n">pq</span><span class="o">.</span><span class="n">decreaseKey</span><span class="p">(</span><span class="n">nextVert</span><span class="p">,</span> <span class="n">newCost</span><span class="p">)</span></code></pre></div>


</div>



<span id="/2017/03/14/%E7%94%A8python%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98/" class="leancloud_visitors" data-flag-title="用Python解决数据结构与算法问题">
  <span class="post-meta-item-text">文章阅读量 </span>
  <span class="leancloud-visitors-count">1000000</span>
  <p></p>
</span>
<div id="vcomments"></div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script type="text/javascript">
  new Valine({
      el: '#vcomments' ,
      appId: 'ets5MnLq4PcezyQ5V12Rn2yc-gzGzoHsz',
      appKey: '0PRGA047aMY95OeydaayLDEK',
      verify:  false , 
      avatar:'mm', 
      placeholder: '说点什么吧...',
      visitor:  true 
  });
</script>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

  </body>
</html>

